# Easy
### 1050. Actors and Directors Who Cooperated At Least Three Times
```sql
SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(*) >= 3
```
---
### 1068. Product Sales Analysis I
```sql
SELECT
    P.PRODUCT_NAME,
    S.YEAR,
    S.PRICE
FROM
    SALES AS S
INNER JOIN
    PRODUCT AS P
ON
    S.PRODUCT_ID = P.PRODUCT_ID;
```
---
### 1069. Product Sales Analysis II
```sql
SELECT
    PRODUCT_ID,
    SUM(QUANTITY) AS TOTAL_QUANTITY
FROM
    SALES
GROUP BY
    PRODUCT_ID;
```
---
### 1075. Project Employees I
```sql
SELECT
    P.PROJECT_ID,
    ROUND(AVG(E.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS
FROM
    PROJECT AS P
INNER JOIN
    EMPLOYEE AS E
ON
    P.EMPLOYEE_ID = E.EMPLOYEE_ID
GROUP BY
    P.PROJECT_ID;
```
---
### 1076. Project Employees II
```sql
SELECT
    PROJECT_ID
FROM
    PROJECT
GROUP BY
    PROJECT_ID
HAVING
    COUNT(EMPLOYEE_ID) = (SELECT MAX(EMPLOYEE_COUNT) FROM (SELECT COUNT(EMPLOYEE_ID) AS EMPLOYEE_COUNT FROM PROJECT GROUP BY PROJECT_ID) AS COUNTS);
```
---
### 1082. Sales Analysis I
```sql
SELECT SELLER_ID
FROM SALES
GROUP BY SELLER_ID
HAVING
    SUM(PRICE) >= ALL (
        SELECT SUM(PRICE)
        FROM SALES
        GROUP BY SELLER_ID
    );
-----------------------
WITH
  SELLERTOPRICE AS (
    SELECT SELLER_ID, SUM(PRICE) AS PRICE
    FROM SALES
    GROUP BY 1
  )
SELECT SELLER_ID
FROM SELLERTOPRICE
WHERE PRICE = (
    SELECT MAX(PRICE)
    FROM SELLERTOPRICE
  );
```
---
### 1083. Sales Analysis II
```sql
SELECT SALES.BUYER_ID
FROM SALES
INNER JOIN PRODUCT
  USING (PRODUCT_ID)
GROUP BY 1
HAVING
  SUM(PRODUCT.PRODUCT_NAME = 's8') > 0
  AND SUM(PRODUCT.PRODUCT_NAME = 'iphone') = 0;
```
---
### 1084. Sales Analysis III
```sql
SELECT
    P.PRODUCT_ID,
    P.PRODUCT_NAME
FROM
    PRODUCT P
JOIN
    SALES S ON P.PRODUCT_ID = S.PRODUCT_ID
GROUP BY
    P.PRODUCT_ID, P.PRODUCT_NAME
HAVING
    MIN(S.SALE_DATE) >= '2019-01-01' AND MAX(S.SALE_DATE) <= '2019-03-31';
```
---
### 1113. Reported Posts
```sql
SELECT
  EXTRA AS REPORT_REASON,
  COUNT(DISTINCT POST_ID) AS REPORT_COUNT
FROM ACTIONS
WHERE
  ACTION = 'report'
  AND DATEDIFF('2019-07-05', ACTION_DATE) = 1
GROUP BY 1;
```
---
### 1141. User Activity for the Past 30 Days I
```sql
SELECT
    ACTIVITY_DATE AS DAY,
    COUNT(DISTINCT USER_ID) AS ACTIVE_USERS
FROM
    ACTIVITY
WHERE
    ACTIVITY_DATE BETWEEN DATEADD(DAY, -29, '2019-07-27') AND '2019-07-27'
GROUP BY
    ACTIVITY_DATE
ORDER BY
    DAY;
```
---
### 1142. User Activity for the Past 30 Days II
```sql
SELECT
  IFNULL(
    ROUND(
      COUNT(DISTINCT SESSION_ID) / COUNT(DISTINCT USER_ID),
      2
    ),
    0.00
  ) AS AVERAGE_SESSIONS_PER_USER
FROM ACTIVITY
WHERE ACTIVITY_DATE BETWEEN '2019-06-28' AND  '2019-07-27';
```
---
### 1148. Article Views I
```sql
SELECT DISTINCT AUTHOR_ID AS ID
FROM VIEWS
WHERE AUTHOR_ID = VIEWER_ID
ORDER BY ID ASC;
```
---
### 1173. Immediate Food Delivery I
```sql
SELECT 
  CAST(
    SUM(
      CASE WHEN ORDER_DATE = CUSTOMER_PREF_DELIVERY_DATE THEN 1 ELSE 0 END
    ) * 100.0 AS DECIMAL(5, 2)
  ) / COUNT(*) AS IMMEDIATE_PERCENTAGE 
FROM 
  DELIVERY;
```
---
### 1179. Reformat Department Table
```sql
SELECT
    ID,
    SUM(CASE WHEN MONTH = 'Jan' THEN REVENUE ELSE NULL END) AS JAN_REVENUE,
    SUM(CASE WHEN MONTH = 'Feb' THEN REVENUE ELSE NULL END) AS FEB_REVENUE,
    SUM(CASE WHEN MONTH = 'Mar' THEN REVENUE ELSE NULL END) AS MAR_REVENUE,
    SUM(CASE WHEN MONTH = 'Apr' THEN REVENUE ELSE NULL END) AS APR_REVENUE,
    SUM(CASE WHEN MONTH = 'May' THEN REVENUE ELSE NULL END) AS MAY_REVENUE,
    SUM(CASE WHEN MONTH = 'Jun' THEN REVENUE ELSE NULL END) AS JUN_REVENUE,
    SUM(CASE WHEN MONTH = 'Jul' THEN REVENUE ELSE NULL END) AS JUL_REVENUE,
    SUM(CASE WHEN MONTH = 'Aug' THEN REVENUE ELSE NULL END) AS AUG_REVENUE,
    SUM(CASE WHEN MONTH = 'Sep' THEN REVENUE ELSE NULL END) AS SEP_REVENUE,
    SUM(CASE WHEN MONTH = 'Oct' THEN REVENUE ELSE NULL END) AS OCT_REVENUE,
    SUM(CASE WHEN MONTH = 'Nov' THEN REVENUE ELSE NULL END) AS NOV_REVENUE,
    SUM(CASE WHEN MONTH = 'Dec' THEN REVENUE ELSE NULL END) AS DEC_REVENUE
FROM DEPARTMENT
--------------------------------
SELECT
    ID,
    [Jan] AS Jan_Revenue,
    [Feb] AS Feb_Revenue,
    [Mar] AS Mar_Revenue,
    [Apr] AS Apr_Revenue,
    [May] AS May_Revenue,
    [Jun] AS Jun_Revenue,
    [Jul] AS Jul_Revenue,
    [Aug] AS Aug_Revenue,
    [Sep] AS Sep_Revenue,
    [Oct] AS Oct_Revenue,
    [Nov] AS Nov_Revenue,
    [Dec] AS Dec_Revenue
FROM (
    SELECT ID, REVENUE, MONTH FROM DEPARTMENT
) S
PIVOT (
    SUM(REVENUE)
    FOR MONTH IN (
        [Jan],[Feb],[Mar],[Apr],[May],[Jun],
        [Jul],[Aug],[Sep],[Oct],[Nov],[Dec] )
) P;
```
---
### 1211. Queries Quality and Percentage
```sql
SELECT QUERY_NAME,
       ROUND(SUM(RATING*1.0/POSITION)*1.0/COUNT(*),2) AS QUALITY,
       ROUND(COUNT(CASE WHEN RATING<3 THEN 1 ELSE NULL END)*100.00/COUNT(*), 2) AS POOR_QUERY_PERCENTAGE 
FROM QUERIES
GROUP BY QUERY_NAME
```
---
### 1241. Number of Comments per Post
```sql
WITH POSTS AS (
  SELECT 
    DISTINCT SUB_ID AS POST_ID 
  FROM 
    SUBMISSIONS 
  WHERE 
    PARENT_ID IS NULL
) 
SELECT 
  POSTS.POST_ID, 
  COUNT(DISTINCT COMMENTS.SUB_ID) AS NUMBER_OF_COMMENTS 
FROM 
  POSTS 
  LEFT JOIN SUBMISSIONS AS COMMENTS ON (
    POSTS.POST_ID = COMMENTS.PARENT_ID
  ) 
GROUP BY 
  1;
```
---
### 1251. Average Selling Price
```sql
SELECT 
  P.PRODUCT_ID, 
  ISNULL(
    ROUND(SUM(P.PRICE * U.UNITS * 1.0) / SUM(U.UNITS),2),0
  ) AS AVERAGE_PRICE 
FROM 
  PRICES P 
  LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID 
  AND U.PURCHASE_DATE BETWEEN P.START_DATE 
  AND P.END_DATE 
GROUP BY 
  P.PRODUCT_ID;
```
---
### 1280. Students and Examinations
```sql
SELECT 
  STUDENTS.STUDENT_ID, 
  STUDENTS.STUDENT_NAME, 
  SUBJECTS.SUBJECT_NAME, 
  COUNT(EXAMINATIONS.STUDENT_ID) AS ATTENDED_EXAMS 
FROM 
  STUDENTS CROSS 
  JOIN SUBJECTS 
  LEFT JOIN EXAMINATIONS ON (
    STUDENTS.STUDENT_ID = EXAMINATIONS.STUDENT_ID 
    AND SUBJECTS.SUBJECT_NAME = EXAMINATIONS.SUBJECT_NAME
  ) 
GROUP BY 
  STUDENTS.STUDENT_ID, STUDENTS.STUDENT_NAME, SUBJECTS.SUBJECT_NAME 
ORDER BY 
  1, 2, 3
```
---
### 1294. Weather Type in Each Country
```sql
SELECT
  COUNTRY_NAME,
  (
    CASE
      WHEN AVG(WEATHER.WEATHER_STATE * 1.0) <= 15.0 THEN 'COLD'
      WHEN AVG(WEATHER.WEATHER_STATE * 1.0) >= 25.0 THEN 'HOT'
      ELSE 'WARM'
    END
  ) AS WEATHER_TYPE
FROM COUNTRIES
INNER JOIN WEATHER
  USING (COUNTRY_ID)
WHERE DAY BETWEEN '2019-11-01' AND '2019-11-30'
GROUP BY 1;
```
---
### 1303. Find the Team Size
```sql
SELECT
  EMPLOYEE_ID,
  COUNT(*) OVER(PARTITION BY TEAM_ID) AS TEAM_SIZE
FROM EMPLOYEE;
```
---
### 1322. Ads Performance
```sql
SELECT
    AD_ID,
    ROUND(IFNULL(SUM(ACTION = 'Clicked') / SUM(ACTION IN ('Clicked', 'Viewed')) * 100, 0), 2) AS CTR
FROM ADS
GROUP BY 1
ORDER BY 2 DESC, 1;
```
---
### 1327. List the Products Ordered in a Period
```sql
SELECT
  P.PRODUCT_NAME,
  SUM(O.UNIT) AS UNIT
FROM PRODUCTS P
INNER JOIN ORDERS O
ON P.PRODUCT_ID = O.PRODUCT_ID
WHERE FORMAT(O.ORDER_DATE, 'yyyy-MM') = '2020-02'
GROUP BY P.PRODUCT_NAME
HAVING SUM(O.UNIT) >= 100;
```
---
### 1350. Students With Invalid Departments
```sql
SELECT
  STUDENTS.ID,
  STUDENTS.NAME
FROM STUDENTS
LEFT JOIN DEPARTMENTS
  ON STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID
WHERE DEPARTMENTS.ID IS NULL;
```
---
### 1378. Replace Employee ID With The Unique Identifier
```sql
SELECT
  EU.UNIQUE_ID,
  E.NAME
FROM EMPLOYEES E
LEFT JOIN EMPLOYEEUNI EU
ON E.ID = EU.ID;
```
---
### 1407. Top Travellers
```sql
SELECT 
  NAME, TRAVELLED_DISTANCE 
FROM 
  (
    SELECT 
      U.ID, U.NAME, ISNULL(SUM(R.DISTANCE), 0) AS TRAVELLED_DISTANCE 
    FROM 
      USERS U 
      LEFT JOIN RIDES R ON (U.ID = R.USER_ID) 
    GROUP BY 
      U.ID, U.NAME
  ) D 
ORDER BY 2 DESC, 1;
```
---
### 1421. NPV Queries
```sql
SELECT
  Q.ID,
  Q.YEAR,
  ISNULL(N.NPV, 0) AS NPV
FROM QUERIES Q
LEFT JOIN NPV N
ON Q.ID = N.ID AND Q.YEAR = N.YEAR;
```
---
### 1435. Create a Session Bar Chart
```sql
SELECT 
  '[0-5>' AS BIN, 
  COUNT(1) AS TOTAL 
FROM SESSIONS WHERE DURATION < 300 
UNION 
SELECT 
  '[5-10>' AS BIN, 
  COUNT(1) AS TOTAL 
FROM SESSIONS WHERE 300 <= DURATION AND DURATION < 600 
UNION 
SELECT 
  '[10-15>' AS BIN, 
  COUNT(1) AS TOTAL 
FROM SESSIONS WHERE 600 <= DURATION AND DURATION < 900 
UNION 
SELECT 
  '15 OR MORE' AS BIN, 
  COUNT(1) AS TOTAL 
FROM SESSIONS WHERE 900 <= DURATION;
```
---
### 1484. Group Sold Products By The Date
```sql
WITH T AS (
    SELECT DISTINCT * FROM ACTIVITIES
    )
SELECT 
     SELL_DATE
    ,COUNT(1) AS NUM_SOLD
    ,STRING_AGG(PRODUCT,',') WITHIN GROUP (ORDER BY PRODUCT) AS PRODUCTS
FROM T
GROUP BY SELL_DATE
ORDER BY SELL_DATE
```
---
### 1495. Friendly Movies Streamed Last Month
```sql
SELECT DISTINCT CONTENT.TITLE
FROM CONTENT
INNER JOIN TVPROGRAM  USING (CONTENT_ID)
WHERE
    CONTENT.KIDS_CONTENT = 'Y'
    AND CONTENT.CONTENT_TYPE = 'Movies'
    AND DATE_FORMAT(TVPROGRAM.PROGRAM_DATE, '%Y-%M') = '2020-06';
```
---
### 1511. Customer Order Frequency
```sql
SELECT 
  C.CUSTOMER_ID, 
  C.NAME 
FROM 
  ORDERS AS O 
  JOIN PRODUCT AS P ON O.PRODUCT_ID = P.PRODUCT_ID 
  JOIN CUSTOMERS AS C ON O.CUSTOMER_ID = C.CUSTOMER_ID 
WHERE 
  YEAR(O.ORDER_DATE) = 2020 
GROUP BY 
  C.CUSTOMER_ID, 
  C.NAME 
HAVING 
  SUM(
    CASE WHEN MONTH(O.ORDER_DATE) = 6 THEN O.QUANTITY * P.PRICE ELSE 0 END
  ) >= 100 
  AND SUM(
    CASE WHEN MONTH(O.ORDER_DATE) = 7 THEN O.QUANTITY * P.PRICE ELSE 0 END
  ) >= 100;

```
---
### 1517. Find Users With Valid E-Mails
```sql
SELECT 
    *
FROM
    USERS
WHERE
    -- last 13 digits should be '@leetcode.com'
    RIGHT(MAIL,13) = '@leetcode.com' COLLATE Latin1_General_CS_AS
    -- before the '@leetcode.com', there should not be any digit which are not a-z , A-Z , 0-9 , - , . , _
    AND LEFT(MAIL, LEN(MAIL) - 13) NOT LIKE '%[^a-zA-Z0-9_.-]%'
    -- 1st digit should be any digit of a-z or A-Z
    AND LEFT(MAIL,1) LIKE '[a-zA-Z]%';
```
---
### 1527. Patients With a Condition
```sql
SELECT *
FROM PATIENTS
WHERE
    CONDITIONS LIKE 'DIAB1%' OR
    CONDITIONS LIKE '% DIAB1%';
```
---
### 1543. Fix Product Name Format
```sql
WITH
    T AS (
        SELECT
            LOWER(TRIM(PRODUCT_NAME)) AS PRODUCT_NAME,
            DATE_FORMAT(SALE_DATE, '%Y-%M') AS SALE_DATE
        FROM SALES
    )
SELECT PRODUCT_NAME, SALE_DATE, COUNT(1) AS TOTAL
FROM T
GROUP BY 1, 2
ORDER BY 1, 2;
```
---
### 1565. Unique Orders and Customers Per Month
```sql
SELECT
    FORMAT(ORDER_DATE, 'yyyy-MM') AS MONTH,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    COUNT(DISTINCT CUSTOMER_ID) AS CUSTOMER_COUNT
FROM
    ORDERS
WHERE
    INVOICE > 20
GROUP BY
    FORMAT(ORDER_DATE, 'yyyy-MM')
ORDER BY
    MONTH;
```
---
### 1571. Warehouse Manager
```sql
SELECT
    W.NAME AS WAREHOUSE_NAME,
    SUM(W.UNITS * P.WIDTH * P.LENGTH * P.HEIGHT) AS VOLUME
FROM
    WAREHOUSE W
JOIN
    PRODUCTS P ON W.PRODUCT_ID = P.PRODUCT_ID
GROUP BY
    W.NAME;
```
---
### 1581. Customer Who Visited but Did Not Make Any Transactions
```sql
SELECT
    V.CUSTOMER_ID,
    COUNT(V.VISIT_ID) AS COUNT_NO_TRANS
FROM
    VISITS V
LEFT JOIN
    TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID
WHERE
    T.VISIT_ID IS NULL
GROUP BY
    V.CUSTOMER_ID;
```
---
### 1587. Bank Account Summary II
```sql
SELECT
    U.NAME,
    SUM(T.AMOUNT) AS BALANCE
FROM
    USERS U
JOIN
    TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT
GROUP BY
    U.NAME
HAVING
    SUM(T.AMOUNT) > 10000;
```
---
### 1607. Sellers With No Sales
```sql
SELECT
    S.SELLER_NAME
FROM
    SELLER S
LEFT JOIN
    ORDERS O ON S.SELLER_ID = O.SELLER_ID AND YEAR(O.SALE_DATE) = 2020
WHERE
    O.ORDER_ID IS NULL;
```
---
### 1623. All Valid Triplets That Can Represent a Country
```sql
SELECT
    SA.STUDENT_NAME AS MEMBER_A,
    SB.STUDENT_NAME AS MEMBER_B,
    SC.STUDENT_NAME AS MEMBER_C
FROM
    SCHOOLA SA
CROSS JOIN
    SCHOOLB SB
CROSS JOIN
    SCHOOLC SC
WHERE
    SA.STUDENT_NAME != SB.STUDENT_NAME
    AND SA.STUDENT_NAME != SC.STUDENT_NAME
    AND SB.STUDENT_NAME != SC.STUDENT_NAME
    AND SA.STUDENT_ID != SB.STUDENT_ID
    AND SA.STUDENT_ID != SC.STUDENT_ID
    AND SB.STUDENT_ID != SC.STUDENT_ID;
--------------------------------
SELECT
    S1.STUDENT_ID AS STUDENT_ID1,
    S2.STUDENT_ID AS STUDENT_ID2,
    S3.STUDENT_ID AS STUDENT_ID3
FROM
    SCHOOLA S1
JOIN
    SCHOOLB S2 ON S1.STUDENT_NAME != S2.STUDENT_NAME AND S1.STUDENT_ID != S2.STUDENT_ID
JOIN
    SCHOOLC S3 ON S2.STUDENT_NAME != S3.STUDENT_NAME AND S1.STUDENT_NAME != S3.STUDENT_NAME AND S1.STUDENT_ID != S3.STUDENT_ID AND S2.STUDENT_ID != S3.STUDENT_ID
ORDER BY
    STUDENT_ID1, STUDENT_ID2, STUDENT_ID3;
```
---
### 1633. Percentage of Users Attended a Contest
```sql
SELECT
    CONTEST_ID,
    ROUND(COUNT(USER_ID) * 100.0 / (SELECT COUNT(*) FROM USERS), 2) AS PERCENTAGE
FROM
    REGISTER
GROUP BY
    CONTEST_ID
ORDER BY
    PERCENTAGE DESC, CONTEST_ID;
```
---
### 1661. Average Time of Process per Machine
```sql
SELECT
    A1.MACHINE_ID,
    ROUND(AVG(CAST(A2.TIMESTAMP AS DECIMAL(10, 3)) - CAST(A1.TIMESTAMP AS DECIMAL(10, 3))), 3) AS PROCESSING_TIME
FROM
    ACTIVITY A1
JOIN
    ACTIVITY A2 ON A1.MACHINE_ID = A2.MACHINE_ID
    AND A1.PROCESS_ID = A2.PROCESS_ID
    AND A1.ACTIVITY_TYPE = 'START'
    AND A2.ACTIVITY_TYPE = 'END'
GROUP BY
    A1.MACHINE_ID;
```
---
### 1667. Fix Names in a Table
```sql
SELECT
    USER_ID,
    UPPER(LEFT(NAME, 1)) + LOWER(SUBSTRING(NAME, 2, LEN(NAME))) AS NAME
FROM
    USERS
ORDER BY
    USER_ID;
```
---
### 1677. Product's Worth Over Invoices
```sql
SELECT
  PRODUCT.NAME,
  ISNULL(SUM(I.REST), 0) AS REST,
  ISNULL(SUM(I.PAID), 0) AS PAID,
  ISNULL(SUM(I.CANCELED), 0) AS CANCELED,
  ISNULL(SUM(I.REFUNDED), 0) AS REFUNDED
FROM PRODUCT P
LEFT JOIN INVOICE I
ON I.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1
ORDER BY 1;
```
---
### 1683. Invalid Tweets
```sql
SELECT
    TWEET_ID
FROM
    TWEETS
WHERE
    LEN(CONTENT) > 15;
```
---
### 1693. Daily Leads and Partners
```sql
SELECT
    DATE_ID,
    MAKE_NAME,
    COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS,
    COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS
FROM
    DAILYSALES
GROUP BY
    DATE_ID,
    MAKE_NAME;
```
---
### 1729. Find Followers Count
```sql
SELECT
    USER_ID,
    COUNT(FOLLOWER_ID) AS FOLLOWERS_COUNT
FROM
    FOLLOWERS
GROUP BY
    USER_ID
ORDER BY
    USER_ID;
```
---
### 1731. The Number of Employees Which Report to Each Employee
```sql
SELECT
    M.EMPLOYEE_ID,
    M.NAME,
    COUNT(R.EMPLOYEE_ID) AS REPORTS_COUNT,
    ROUND(AVG(CAST(R.AGE AS DECIMAL)), 0) AS AVERAGE_AGE
FROM
    EMPLOYEES M -- M FOR MANAGER
JOIN
    EMPLOYEES R ON M.EMPLOYEE_ID = R.REPORTS_TO -- R FOR REPORT
GROUP BY
    M.EMPLOYEE_ID,
    M.NAME
ORDER BY
    M.EMPLOYEE_ID;
```
---
### 1741. Find Total Time Spent by Each Employee
```sql
SELECT
    EVENT_DAY AS DAY,
    EMP_ID,
    SUM(OUT_TIME - IN_TIME) AS TOTAL_TIME
FROM
    EMPLOYEES
GROUP BY
    EVENT_DAY,
    EMP_ID;
```
---
### 175. Combine Two Tables
```sql
SELECT
    P.FIRSTNAME,
    P.LASTNAME,
    A.CITY,
    A.STATE
FROM
    PERSON P
LEFT JOIN
    ADDRESS A ON P.PERSONID = A.PERSONID;
```
---
### 1757. Recyclable and Low Fat Products
```sql
SELECT PRODUCT_ID
FROM PRODUCTS
WHERE LOW_FATS = 'Y' AND RECYCLABLE = 'Y';
```
---
### 1777. Product's Price for Each Store
```sql
SELECT
    PRODUCT_ID,
    MAX(CASE WHEN STORE = 'store1' THEN PRICE END) AS STORE1,
    MAX(CASE WHEN STORE = 'store2' THEN PRICE END) AS STORE2,
    MAX(CASE WHEN STORE = 'store3' THEN PRICE END) AS STORE3
FROM
    PRODUCTS
GROUP BY
    PRODUCT_ID;
```
---
### 1789. Primary Department for Each Employee
```sql
SELECT EMPLOYEE_ID, DEPARTMENT_ID
FROM EMPLOYEE
WHERE PRIMARY_FLAG = 'Y'
UNION
SELECT EMPLOYEE_ID, MIN(DEPARTMENT_ID) AS DEPARTMENT_ID 
FROM EMPLOYEE
GROUP BY EMPLOYEE_ID
HAVING COUNT(EMPLOYEE_ID) = 1;
-------------------------
SELECT E.EMPLOYEE_ID, 
COALESCE(
MAX(CASE WHEN E.PRIMARY_FLAG = 'Y' THEN E.DEPARTMENT_ID ELSE NULL END),
MIN(CASE WHEN E.PRIMARY_FLAG = 'N' THEN E.DEPARTMENT_ID ELSE NULL END)
) 
DEPARTMENT_ID 
FROM EMPLOYEE E
GROUP BY E.EMPLOYEE_ID
HAVING 
COUNT(CASE WHEN E.PRIMARY_FLAG = 'Y' THEN E.DEPARTMENT_ID ELSE NULL END) = 1 
OR COUNT(CASE WHEN E.PRIMARY_FLAG = 'N' THEN E.DEPARTMENT_ID ELSE NULL END) = 1
```
---
### 1795. Rearrange Products Table
```sql
SELECT PRODUCT_ID, 'store1' AS STORE, STORE1 AS PRICE
FROM PRODUCTS
WHERE STORE1 IS NOT NULL
UNION ALL
SELECT PRODUCT_ID, 'store2' AS STORE, STORE2 AS PRICE
FROM PRODUCTS
WHERE STORE2 IS NOT NULL
UNION ALL
SELECT PRODUCT_ID, 'store3' AS STORE, STORE3 AS PRICE
FROM PRODUCTS
WHERE STORE3 IS NOT NULL;
```
---
### 1809. Ad-Free Sessions
```sql
SELECT DISTINCT
    P.SESSION_ID
FROM
    PLAYBACK P
LEFT JOIN
    ADS A ON P.CUSTOMER_ID = A.CUSTOMER_ID
    AND A.TIMESTAMP BETWEEN P.START_TIME AND P.END_TIME
WHERE
    A.AD_ID IS NULL;
```
---
### 181. Employees Earning More Than Their Managers
```sql
SELECT
    E1.NAME AS EMPLOYEE
FROM
    EMPLOYEE E1
JOIN
    EMPLOYEE E2 ON E1.MANAGERID = E2.ID
WHERE
    E1.SALARY > E2.SALARY;
```
---
### 182. Duplicate Emails
```sql
SELECT
    EMAIL
FROM
    PERSON
GROUP BY
    EMAIL
HAVING
    COUNT(EMAIL) > 1;
```
---
### 1821. Find Customers With Positive Revenue this Year
```sql
SELECT
    CUSTOMER_ID
FROM
    CUSTOMERS
WHERE
    YEAR = 2021 AND REVENUE > 0;
```
---
### 183. Customers Who Never Order
```sql
SELECT
    C.NAME AS CUSTOMERS
FROM
    CUSTOMERS C
LEFT JOIN
    ORDERS O ON C.ID = O.CUSTOMERID
WHERE
    O.ID IS NULL;
```
---
### 1853. Convert Date Format
```sql
SELECT
    FORMAT(DAY, 'dddd, MMMM d, yyyy') AS DAY
FROM
    DAYS;
```
---
### 1873. Calculate Special Bonus
```sql
SELECT 
    EMPLOYEE_ID, 
    CASE 
        WHEN NAME LIKE 'M%' OR EMPLOYEE_ID % 2 = 0 THEN 0 
        ELSE SALARY 
    END AS BONUS
FROM EMPLOYEES
ORDER BY EMPLOYEE_ID;
```
---
### 1890. The Latest Login in
```sql
SELECT USER_ID, MAX(TIME_STAMP) LAST_STAMP
FROM LOGINS
WHERE YEAR(TIME_STAMP)=2020
GROUP BY USER_ID
```
---
### 1939. Users That Actively Request Confirmation Messages
```sql
SELECT DISTINCT C1.USER_ID
    FROM CONFIRMATIONS C1
    INNER JOIN CONFIRMATIONS C2
    WHERE C1.USER_ID = C2.USER_ID
    AND C1.TIME_STAMP < C2.TIME_STAMP
    AND TIMESTAMPDIFF(SECOND, C1.TIME_STAMP, C2.TIME_STAMP) <= 86400;
---------------
WITH
  USERTOTIMESTAMPDIFF AS (
    SELECT USER_ID,
      TIMESTAMPDIFF(
        SECOND,
        TIME_STAMP,
        LEAD(TIME_STAMP) OVER(
          PARTITION BY USER_ID
          ORDER BY TIME_STAMP
        )
      ) AS TIMESTAMP_DIFF
    FROM CONFIRMATIONS
  )
SELECT DISTINCT USER_ID
FROM USERTOTIMESTAMPDIFF
WHERE TIMESTAMP_DIFF <= 24 * 60 * 60;
```
---
### 196. Delete Duplicate Emails
```sql
DELETE P1 
FROM PERSON P1, PERSON P2
WHERE P1.EMAIL = P2.EMAIL 
AND P1.ID>P2.ID;
--------------
DELETE FROM PERSON 
WHERE ID NOT IN (
  SELECT MIN(ID)
  FROM PERSON 
  GROUP BY EMAIL 
);
```
---
### 1965. Employees With Missing Information
```sql
SELECT EMPLOYEE_ID 
FROM EMPLOYEES 
WHERE EMPLOYEE_ID NOT IN(SELECT EMPLOYEE_ID FROM SALARIES) 
UNION ALL 
SELECT EMPLOYEE_ID
FROM SALARIES 
WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM EMPLOYEES) 
ORDER BY EMPLOYEE_ID ASC
-----------------------------------------------
SELECT ISNULL(E.EMPLOYEE_ID,S.EMPLOYEE_ID) AS EMPLOYEE_ID
FROM EMPLOYEES E FULL JOIN SALARIES S
ON E.EMPLOYEE_ID  =S.EMPLOYEE_ID 
WHERE S.EMPLOYEE_ID IS NULL OR E.EMPLOYEE_ID IS NULL 
ORDER BY  EMPLOYEE_ID ASC 
```
---
### 197. Rising Temperature
```sql
WITH CTE AS (
  SELECT 
    *, 
    LAG(TEMPERATURE) OVER (ORDER BY RECORDDATE ASC) AS PREV_TEMP, 
    LAG(RECORDDATE) OVER (ORDER BY RECORDDATE ASC) AS PREV_DATE 
  FROM 
    WEATHER
) 
SELECT 
  ID 
FROM 
  CTE 
WHERE 
  TEMPERATURE > PREV_TEMP 
  AND DATEDIFF(DAY, PREV_DATE, RECORDDATE)= 1
```
---
### 1978. Employees Whose Manager Left the Company
```sql
SELECT E.EMPLOYEE_ID
FROM EMPLOYEES E
LEFT JOIN EMPLOYEES M
ON M.EMPLOYEE_ID =E.MANAGER_ID
WHERE E.SALARY < 30000 AND M.EMPLOYEE_ID IS NULL AND E.MANAGER_ID IS NOT NULL
ORDER BY EMPLOYEE_ID
```
---
### 2026. Low-Quality Problems
```sql
SELECT PROBLEM_ID
FROM PROBLEMS
WHERE LIKES / (LIKES + DISLIKES) < 0.6
ORDER BY PROBLEM_ID;
```
---
### 2072. The Winner University
```sql
WITH NYU_CTE AS (
    SELECT COUNT(*) AS CNT FROM NEWYORK WHERE SCORE >= 90
), CU_CTE AS (
    SELECT COUNT(*) AS CNT FROM CALIFORNIA WHERE SCORE >= 90
)
SELECT
    (CASE
     WHEN N.CNT > C.CNT THEN 'NEW YORK UNIVERSITY'
     WHEN N.CNT < C.CNT THEN 'CALIFORNIA UNIVERSITY'
     ELSE 'NO WINNER'
     END) AS WINNER
FROM NYU_CTE N, CU_CTE C;
```
---
### 2082. The Number of Rich Customers
```sql
SELECT
    COUNT(DISTINCT(CUSTOMER_ID)) AS RICH_COUNT
FROM
    STORE
WHERE
    AMOUNT > 500;
```
---
### 2205. The Number of Users That Are Eligible for Discount
```sql
SELECT 
  COUNT(DISTINCT USER_ID) AS USER_CNT 
FROM 
  PURCHASES 
WHERE 
  TIME_STAMP BETWEEN STARTDATE 
  AND ENDDATE 
  AND AMOUNT >= MINAMOUNT
```
---
### 2230. The Users That Are Eligible for Discount
```sql
CREATE PROCEDURE getUserIDs(startDate DATE, endDate DATE, minAmount INT)
BEGIN
  SELECT DISTINCT user_id
  FROM Purchases
  WHERE
    time_stamp BETWEEN startDate AND endDate
    AND amount >= minAmount
  ORDER BY 1;
END
```
---
### 2329. Product Sales Analysis V
```sql
SELECT
    S.USER_ID,
    SUM(S.QUANTITY * P.PRICE) AS SPENDING
FROM
    SALES AS S
JOIN
    PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID
GROUP BY
    S.USER_ID
ORDER BY
    SPENDING DESC, S.USER_ID;
```
---
### 2339. All the Matches of the League
```sql
SELECT
    T1.TEAM_NAME AS HOME_TEAM,
    T2.TEAM_NAME AS AWAY_TEAM
FROM
    TEAMS AS T1
CROSS JOIN
    TEAMS AS T2
WHERE
    T1.TEAM_NAME != T2.TEAM_NAME;
```
---
### 2356. Number of Unique Subjects Taught by Each Teacher
```sql
SELECT
    TEACHER_ID,
    COUNT(DISTINCT SUBJECT_ID) AS CNT
FROM
    TEACHER
GROUP BY
    TEACHER_ID;
```
---
### 2377. Sort the Olympic Table
```sql
SELECT
  COUNTRY,
  GOLD_MEDALS,
  SILVER_MEDALS,
  BRONZE_MEDALS
FROM OLYMPIC
ORDER BY
  GOLD_MEDALS DESC,
  SILVER_MEDALS DESC,
  BRONZE_MEDALS DESC,
  COUNTRY;
```
---
### 2480. Form a Chemical Bond
```sql
SELECT
    A.SYMBOL AS METAL,
    B.SYMBOL AS NONMETAL
FROM
    ELEMENTS AS A
CROSS JOIN
    ELEMENTS AS B
WHERE
    A.TYPE = 'Metal' AND B.TYPE = 'Nonmetal';
```
---
### 2504. Concatenate the Name and the Profession
```sql
SELECT
    PERSON_ID,
    CONCAT(NAME, '(', SUBSTRING(PROFESSION, 1, 1), ')') AS NAME
FROM
    PERSON
ORDER BY
    PERSON_ID DESC;
```
---
### 2668. Find Latest Salaries
```sql
SELECT
    EMP_ID,
    FIRSTNAME,
    LASTNAME,
    MAX(SALARY) AS SALARY,
    DEPARTMENT_ID
FROM
    SALARY
GROUP BY
    EMP_ID,
    FIRSTNAME,
    LASTNAME,
    DEPARTMENT_ID
ORDER BY
    EMP_ID;
```
---
### 2669. Count Artist Occurrences On Spotify Ranking List
```sql
SELECT
    ARTIST,
    COUNT(1) AS OCCURRENCES
FROM SPOTIFY
GROUP BY ARTIST
ORDER BY OCCURRENCES DESC, ARTIST;
```
---
### 2687. Bikes Last Time Used
```sql
SELECT
    BIKE_NUMBER,
    MAX(END_TIME) AS END_TIME
FROM BIKES
GROUP BY BIKE_NUMBER
ORDER BY END_TIME DESC;
```
---
### 2837. Total Traveled Distance
```sql
SELECT
  U.USER_ID,
  U.NAME,
  SUM(ISNULL(R.DISTANCE, 0)) AS TOTAL_TRAVELED_DISTANCE
FROM
  USERS U
  LEFT JOIN RIDES R ON U.USER_ID = R.USER_ID
GROUP BY
  U.USER_ID,
  U.NAME
ORDER BY
  U.USER_ID;
```
---
### 2853. Highest Salaries Difference
```sql
SELECT
  MAX(CASE WHEN DEPARTMENT = 'Engineering' THEN SALARY ELSE 0 END) - MAX(CASE WHEN DEPARTMENT = 'Marketing' THEN SALARY ELSE 0 END) AS SALARY_DIFFERENCE
FROM
  SALARIES;
```
---
### 2985. Calculate Compressed Mean
```sql
SELECT
    ROUND(
        SUM(ITEM_COUNT * ORDER_OCCURRENCES) / SUM(ORDER_OCCURRENCES),
        2
    ) AS AVERAGE_ITEMS_PER_ORDER
FROM ORDERS;
```
---
### 2987. Find Expensive Cities
```sql
SELECT CITY
FROM LISTINGS
GROUP BY CITY
HAVING AVG(PRICE) > (SELECT AVG(PRICE) FROM LISTINGS)
ORDER BY 1
```
---
### 2990. Loan Types
```sql
SELECT
  USER_ID
FROM
  LOANS
GROUP BY
  USER_ID
HAVING
  SUM(CASE WHEN LOAN_TYPE = 'REFINANCE' THEN 1 ELSE 0 END) > 0
  AND SUM(CASE WHEN LOAN_TYPE = 'MORTGAGE' THEN 1 ELSE 0 END) > 0
ORDER BY
  USER_ID;
```
---
### 3051. Find Candidates for Data Scientist Position
```sql
SELECT CANDIDATE_ID
FROM CANDIDATES
WHERE SKILL IN ('Python', 'Tableau', 'PostgreSQL')
GROUP BY 1
HAVING COUNT(1) = 3
ORDER BY 1;
```
---
### 3053. Classifying Triangles by Lengths
```sql
SELECT
  CASE
    WHEN A + B <= C OR A + C <= B OR B + C <= A THEN 'Not a Triangle'
    WHEN A = B AND B = C THEN 'Equilateral'
    WHEN A = B OR B = C OR A = C THEN 'Isosceles'
    ELSE 'Scalene'
  END AS TRIANGLE_TYPE
FROM
  TRIANGLES;
```
---
### 3059. Find All Unique Email Domains
```sql
SELECT
  SUBSTRING(EMAIL, CHARINDEX('@', EMAIL) + 1, LEN(EMAIL)) AS EMAIL_DOMAIN,
  COUNT(*) AS COUNT
FROM
  EMAILS
WHERE
  EMAIL LIKE '%.com'
GROUP BY
  SUBSTRING(EMAIL, CHARINDEX('@', EMAIL) + 1, LEN(EMAIL))
ORDER BY
  EMAIL_DOMAIN;
```
---
### 3150. Invalid Tweets II
```sql
SELECT
  TWEET_ID
FROM
  TWEETS
WHERE
  LEN(CONTENT) > 140
  OR (LEN(CONTENT) - LEN(REPLACE(CONTENT, '@', ''))) > 3
  OR (LEN(CONTENT) - LEN(REPLACE(CONTENT, '#', ''))) > 3
ORDER BY
  TWEET_ID;
```
---
### 3172. Second Day Verification
```sql
SELECT
  E.USER_ID
FROM
  EMAILS E
  INNER JOIN TEXTS T ON E.EMAIL_ID = T.EMAIL_ID
WHERE
  T.SIGNUP_ACTION = 'Verified'
  AND DATEDIFF(DAY, E.SIGNUP_DATE, T.ACTION_DATE) = 1
ORDER BY
  E.USER_ID;
```
---
### 3198. Find Cities in Each State
```sql
SELECT
    STATE,
    STRING_AGG(CITY, ', ') WITHIN GROUP (ORDER BY CITY) AS CITIES
FROM CITIES
GROUP BY STATE
ORDER BY STATE;
```
---
### 3246. Premier League Table Ranking
```sql
SELECT
    TEAM_ID,
    TEAM_NAME,
    WINS * 3 + DRAWS AS POINTS,
    RANK() OVER (ORDER BY (WINS * 3 + DRAWS) DESC) AS POSITION
FROM TEAMSTATS
ORDER BY POINTS DESC, TEAM_NAME;
```
---
### 3358. Books with NULL Ratings
```sql
SELECT BOOK_ID, TITLE, AUTHOR, PUBLISHED_YEAR
FROM BOOKS
WHERE RATING IS NULL
ORDER BY 1;
```
---
### 3415. Find Products with Three Consecutive Digits
```sql
SELECT PRODUCT_ID, NAME
FROM PRODUCTS
WHERE
    (NAME LIKE '%[0-9][0-9][0-9]%'  -- CONTAINS AT LEAST THREE CONSECUTIVE DIGITS
    AND NAME NOT LIKE '%[0-9][0-9][0-9][0-9]%') -- BUT NOT FOUR OR MORE CONSECUTIVE DIGITS
    OR NAME LIKE '[0-9][0-9][0-9]%' -- STARTS WITH EXACTLY THREE DIGITS
    OR NAME LIKE '%[0-9][0-9][0-9]' -- ENDS WITH EXACTLY THREE DIGITS
ORDER BY PRODUCT_ID;
```
---
### 3436. Find Valid Emails
```sql
SELECT * FROM USERS
WHERE UPPER(EMAIL) LIKE '%@%.COM' AND UPPER(EMAIL) NOT LIKE '%[^0-9A-Z_]%@%.COM' AND UPPER(EMAIL) NOT LIKE '%@%[^A-Z]%.COM'
ORDER BY USER_ID
```
---
### 3465. Find Products with Valid Serial Numbers
```sql
SELECT *
FROM PRODUCTS
WHERE
    -- Condition 1: Matches serial numbers at the beginning of the string, followed by a space.
    -- Example: 'SN1234-5678 Some other text'
    DESCRIPTION LIKE 'SN[0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] %' COLLATE Latin1_General_BIN
    OR 
    -- Condition 2: Matches serial numbers that are in the middle of the string, with a space on either side.
    -- Example: 'Some other text SN1234-5678 Some other text'
    DESCRIPTION LIKE '% SN[0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] %' COLLATE Latin1_General_BIN
    OR 
    -- Condition 3: Matches serial numbers at the very end of the string, preceded by a space.
    -- Example: 'Some other text SN1234-5678'
    DESCRIPTION LIKE '% SN[0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]' COLLATE Latin1_General_BIN
ORDER BY 1 ASC;
```
---
### 3570. Find Books with No Available Copies
```sql
WITH BORROWED_BOOK AS (
  SELECT 
    BOOK_ID, COUNT(*) AS CURRENT_BORROWERS 
  FROM 
    BORROWING_RECORDS 
  WHERE 
    RETURN_DATE IS NULL 
  GROUP BY 
    BOOK_ID
) 
SELECT 
  LB.BOOK_ID, TITLE, AUTHOR, GENRE, PUBLICATION_YEAR, CURRENT_BORROWERS 
FROM 
  LIBRARY_BOOKS LB 
  INNER JOIN BORROWED_BOOK BR ON LB.BOOK_ID = BR.BOOK_ID 
  AND (
    BR.CURRENT_BORROWERS - LB.TOTAL_COPIES
  ) = 0 
ORDER BY 
  6 DESC, 2 ASC
```
---
### 3642. Find Books with Polarized Opinions
```sql
```
---
### 511. Game Play Analysis I
```sql
SELECT PLAYER_ID , MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID
```
---
### 512. Game Play Analysis II
```sql
SELECT
    PLAYER_ID,
    DEVICE_ID
FROM ACTIVITY
WHERE
    (PLAYER_ID, EVENT_DATE) IN (
        SELECT
            PLAYER_ID,
            MIN(EVENT_DATE) AS EVENT_DATE
        FROM ACTIVITY
        GROUP BY 1
    );
--------
WITH
    T AS (
        SELECT
            *,
            RANK() OVER (
                PARTITION BY PLAYER_ID
                ORDER BY EVENT_DATE
            ) AS RK
        FROM ACTIVITY
    )
SELECT PLAYER_ID, DEVICE_ID
FROM T
WHERE RK = 1;
```
---
### 577. Employee Bonus
```sql
SELECT NAME, BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE B.BONUS < 1000 OR B.BONUS IS NULL
```
---
### 584. Find Customer Referee
```sql
SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> '2' OR REFEREE_ID IS NULL
```
---
### 586. Customer Placing the Largest Number of Orders
```sql
SELECT TOP 1 CUSTOMER_NUMBER
FROM ORDERS
GROUP BY CUSTOMER_NUMBER
ORDER BY COUNT(*) DESC;
```
---
### 595. Big Countries
```sql
SELECT NAME,POPULATION,AREA FROM WORLD WHERE POPULATION>=25000000 OR AREA>=3000000 
```
---
### 596. Classes With at Least 5 Students
```sql
SELECT CLASS
FROM COURSES
GROUP BY CLASS
HAVING COUNT(STUDENT) >= 5;
```
---
### 597. Friend Requests I: Overall Acceptance Rate
```sql
SELECT
    ROUND(
        ISNULL(
            (SELECT COUNT(*) FROM (SELECT DISTINCT ACCEPTER_ID, REQUESTER_ID FROM REQUESTACCEPTED) AS T1)
            * 1.0 / NULLIF((SELECT COUNT(*) FROM (SELECT DISTINCT SEND_TO_ID, SENDER_ID FROM FRIENDREQUEST) AS T2), 0),
            0
        ),
        2
    ) AS ACCEPT_RATE;
```
---
### 603. Consecutive Available Seats
```sql
WITH CINEMANEIGHBORS AS (
  SELECT
    *,
    LAG(FREE) OVER(ORDER BY SEAT_ID) AS PREV_FREE,
    LEAD(FREE) OVER(ORDER BY SEAT_ID) AS NEXT_FREE
  FROM CINEMA
)
SELECT SEAT_ID
FROM CINEMANEIGHBORS
WHERE FREE = 1
  AND (PREV_FREE = 1 OR NEXT_FREE = 1)
ORDER BY 1;
-----------------
WITH FREESEATSWITHGAP AS (
  SELECT
    SEAT_ID,
    SEAT_ID - ROW_NUMBER() OVER (ORDER BY SEAT_ID) AS GAP_KEY
  FROM CINEMA
  WHERE FREE = 1
)
, FREESEATCOUNTS AS (
  SELECT
    SEAT_ID,
    COUNT(*) OVER (PARTITION BY GAP_KEY) AS GROUP_COUNT
  FROM FREESEATSWITHGAP
)
SELECT
  SEAT_ID
FROM FREESEATCOUNTS
WHERE GROUP_COUNT >= 2
ORDER BY SEAT_ID;
```
---
### 607. Sales Person
```sql
SELECT S.NAME
FROM ORDERS O
INNER JOIN COMPANY C
  ON (O.COM_ID = C.COM_ID AND C.NAME = 'RED')
RIGHT JOIN SALESPERSON S
  ON S.SALES_ID = O.SALES_ID
WHERE O.SALES_ID IS NULL;
```
---
### 610. Triangle Judgement
```sql
SELECT
    *,
    CASE
        WHEN X + Y > Z AND X + Z > Y AND Y + Z > X THEN 'Yes'
        ELSE 'No'
    END AS TRIANGLE
FROM
    TRIANGLE;
```
---
### 613. Shortest Distance in a Line
```sql
SELECT MIN(P2.X - P1.X) AS SHORTEST
FROM
    POINT AS P1
    JOIN POINT AS P2 ON P1.X < P2.X;SELECT MIN(P2.X - P1.X) AS SHORTEST
FROM
    POINT AS P1
    JOIN POINT AS P2 ON P1.X < P2.X;
```
---
### 619. Biggest Single Number
```sql
WITH CTE AS (
  SELECT 
    NUM,COUNT(NUM) COUNTED 
  FROM 
    MYNUMBERS 
  GROUP BY 
    NUM 
  HAVING 
    COUNT(NUM) = 1
) 
SELECT 
  ISNULL(MAX(NUM), NULL) NUM 
FROM 
  CTE
```
---
### 620. Not Boring Movies
```sql
SELECT ID, MOVIE, DESCRIPTION, RATING FROM CINEMA WHERE DESCRIPTION <> 'boring' AND ID % 2 = 1 ORDER BY RATING DESC
```
---
# Medium
### 1045. Customers Who Bought All Products
```sql
WITH PRD_CNT AS (
    SELECT COUNT(DISTINCT PRODUCT_KEY) AS PC FROM PRODUCT
),
CST_CNT AS (
    SELECT CUSTOMER_ID ,COUNT(DISTINCT PRODUCT_KEY) AS CPC FROM CUSTOMER GROUP BY CUSTOMER_ID
)
SELECT CUSTOMER_ID FROM CST_CNT A INNER JOIN PRD_CNT B ON A.CPC = B.PC
```
---
### 1070. Product Sales Analysis III
```sql
WITH EARLY_YR AS (
  SELECT 
    PRODUCT_ID, 
    MIN(YEAR) OVER (PARTITION BY PRODUCT_ID) AS FIRST_YEAR, 
    QUANTITY, 
    PRICE, 
    YEAR 
  FROM 
    SALES
) 
SELECT 
  PRODUCT_ID, FIRST_YEAR, QUANTITY, PRICE 
FROM 
  EARLY_YR 
WHERE 
  FIRST_YEAR = YEAR
```
---
### 1077. Project Employees III
```sql
SELECT
    PROJECT_ID,
    EMPLOYEE_ID
FROM (
    SELECT
        P.PROJECT_ID,
        P.EMPLOYEE_ID,
        DENSE_RANK() OVER(PARTITION BY P.PROJECT_ID ORDER BY E.EXPERIENCE_YEARS DESC) 
        AS MAXEXP
    FROM PROJECT AS P JOIN EMPLOYEE AS E
    ON P.EMPLOYEE_ID = E.EMPLOYEE_ID
    ) 
WHERE MAXEXP = 1
```
---
### 1098. Unpopular Books
```sql
SELECT
  B.BOOK_ID,
  ANY_VALUE(B.NAME) AS NAME
FROM BOOKS B
LEFT JOIN ORDERS O
  ON (
    B.BOOK_ID = O.BOOK_ID
    AND O.DISPATCH_DATE BETWEEN '2018-06-23' AND '2019-06-23'
  )
WHERE
  DATEDIFF(DAY, B.AVAILABLE_FROM, '2019-06-23') > 30
GROUP BY
  B.BOOK_ID
HAVING
  ISNULL(SUM(O.QUANTITY), 0) < 10;
```
---
### 1107. New Users Daily Count
```sql
WITH T AS (
  SELECT
    USER_ID,
    MIN(ACTIVITY_DATE) OVER (PARTITION BY USER_ID) AS LOGIN_DATE
  FROM TRAFFIC
  WHERE
    ACTIVITY = 'LOGIN'
)
SELECT
  LOGIN_DATE,
  COUNT(DISTINCT USER_ID) AS USER_COUNT
FROM T
WHERE
  DATEDIFF(DAY, LOGIN_DATE, '2019-06-30') <= 90
GROUP BY
  LOGIN_DATE;
```
---
### 1112. Highest Grade For Each Student
```sql
WITH T AS (
    SELECT
        STUDENT_ID,
        COURSE_ID,
        GRADE,
        RANK() OVER (
            PARTITION BY STUDENT_ID
            ORDER BY GRADE DESC, COURSE_ID
        ) AS RK
    FROM ENROLLMENTS
)
SELECT
    STUDENT_ID,
    COURSE_ID,
    GRADE
FROM T
WHERE
    RK = 1
ORDER BY
    STUDENT_ID;
```
---
### 1126. Active Businesses
```sql
SELECT
  T1.BUSINESS_ID
FROM
  EVENTS AS T1
  JOIN (
    SELECT
      EVENT_TYPE,
      AVG(OCCURENCES) AS OCCURENCES
    FROM EVENTS
    GROUP BY
      EVENT_TYPE
  ) AS T2
    ON T1.EVENT_TYPE = T2.EVENT_TYPE
WHERE
  T1.OCCURENCES > T2.OCCURENCES
GROUP BY
  T1.BUSINESS_ID
HAVING
  COUNT(*) > 1;
```
---
### 1132. Reported Posts II
```sql
WITH T AS (
    SELECT
        CAST(COUNT(DISTINCT T2.POST_ID) AS FLOAT) / NULLIF(COUNT(DISTINCT T1.POST_ID), 0) * 100 AS PERCENT
    FROM
        ACTIONS AS T1
        LEFT JOIN REMOVALS AS T2
            ON T1.POST_ID = T2.POST_ID
    WHERE
        T1.EXTRA = 'spam'
    GROUP BY
        T1.ACTION_DATE
)
SELECT
    ROUND(AVG(PERCENT), 2) AS AVERAGE_DAILY_PERCENT
FROM
    T;
```
---
### 1149. Article Views II
```sql
SELECT
  DISTINCT VIEWER_ID AS ID
FROM VIEWS
GROUP BY
  VIEWER_ID,
  VIEW_DATE
HAVING
  COUNT(DISTINCT ARTICLE_ID) > 1
ORDER BY
  VIEWER_ID;
```
---
### 1158. Market Analysis I
```sql
SELECT 
  USER_ID AS BUYER_ID, 
  JOIN_DATE, 
  COUNT(ORDER_ID) AS ORDERS_IN_2019 
FROM 
  USERS U 
  LEFT JOIN ORDERS O ON U.USER_ID = O.BUYER_ID 
  AND YEAR(O.ORDER_DATE) = 2019 
GROUP BY 
  USER_ID, 
  JOIN_DATE
ORDER BY 1
```
---
### 1164. Product Price at a Given Date
```sql
WITH LATESTPRICES AS (
    SELECT
        PRODUCT_ID,
        NEW_PRICE AS PRICE,
        ROW_NUMBER() OVER (PARTITION BY PRODUCT_ID ORDER BY CHANGE_DATE DESC) AS RN
    FROM
        PRODUCTS
    WHERE
        CHANGE_DATE <= '2019-08-16'
),
ALLPRODUCTS AS (
    SELECT DISTINCT PRODUCT_ID
    FROM PRODUCTS
)
SELECT
    AP.PRODUCT_ID,
    COALESCE(LP.PRICE, 10) AS PRICE
FROM
    ALLPRODUCTS AP
LEFT JOIN
    LATESTPRICES LP ON AP.PRODUCT_ID = LP.PRODUCT_ID AND LP.RN = 1;
```
---
### 1174. Immediate Food Delivery II
```sql
WITH FIRSTORDERS AS (
    SELECT
        CUSTOMER_ID,
        ORDER_DATE,
        CUSTOMER_PREF_DELIVERY_DATE,
        ROW_NUMBER() OVER (PARTITION BY CUSTOMER_ID ORDER BY ORDER_DATE) AS RN
    FROM
        DELIVERY
)
SELECT
    ROUND(SUM(CASE WHEN ORDER_DATE = CUSTOMER_PREF_DELIVERY_DATE THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS IMMEDIATE_PERCENTAGE
FROM
    FIRSTORDERS
WHERE
    RN = 1;
```
---
### 1193. Monthly Transactions I
```sql
SELECT
    FORMAT(TRANS_DATE, 'yyyy-MM') AS MONTH,
    COUNTRY,
    COUNT(ID) AS TRANS_COUNT,
    SUM(CASE WHEN STATE = 'approved' THEN 1 ELSE 0 END) AS APPROVED_COUNT,
    SUM(AMOUNT) AS TRANS_TOTAL_AMOUNT,
    SUM(CASE WHEN STATE = 'approved' THEN AMOUNT ELSE 0 END) AS APPROVED_TOTAL_AMOUNT
FROM
    TRANSACTIONS
GROUP BY
    FORMAT(TRANS_DATE, 'yyyy-MM'),
    COUNTRY;
```
---
### 1204. Last Person to Fit in the Bus
```sql
WITH RN_SM AS (
  SELECT 
    *, 
    SUM(WEIGHT) OVER (ORDER BY TURN ASC) AS RUN_SUM 
  FROM 
    QUEUE
) 
SELECT 
  TOP 1 PERSON_NAME 
FROM 
  RN_SM 
WHERE 
  RUN_SUM <= 1000 
ORDER BY 
  RUN_SUM DESC
```
---
### 1205. Monthly Transactions II
```sql
WITH T AS (
    SELECT ID, COUNTRY, STATE, AMOUNT, TRANS_DATE
    FROM TRANSACTIONS
    UNION ALL
    SELECT T.ID, T.COUNTRY, 'chargeback' AS STATE, T.AMOUNT, C.TRANS_DATE
    FROM
        TRANSACTIONS AS T
        JOIN CHARGEBACKS AS C ON T.ID = C.TRANS_ID
)
SELECT
    FORMAT(TRANS_DATE, 'yyyy-MM') AS MONTH,
    COUNTRY,
    SUM(CASE WHEN STATE = 'approved' THEN 1 ELSE 0 END) AS APPROVED_COUNT,
    SUM(CASE WHEN STATE = 'approved' THEN AMOUNT ELSE 0 END) AS APPROVED_AMOUNT,
    SUM(CASE WHEN STATE = 'chargeback' THEN 1 ELSE 0 END) AS CHARGEBACK_COUNT,
    SUM(CASE WHEN STATE = 'chargeback' THEN AMOUNT ELSE 0 END) AS CHARGEBACK_AMOUNT
FROM T
GROUP BY
    FORMAT(TRANS_DATE, 'yyyy-MM'),
    COUNTRY
HAVING
    SUM(CASE WHEN STATE = 'approved' THEN AMOUNT ELSE 0 END) > 0 OR
    SUM(CASE WHEN STATE = 'chargeback' THEN AMOUNT ELSE 0 END) > 0;
```
---
### 1212. Team Scores in Football Tournament
```sql
WITH TWOWAYMATCHES AS (
    SELECT
        HOST_TEAM AS TEAM_ID,
        HOST_GOALS AS GOALS,
        GUEST_GOALS AS OPPONENT_GOALS
    FROM
        MATCHES
    UNION ALL
    SELECT
        GUEST_TEAM AS TEAM_ID,
        GUEST_GOALS AS GOALS,
        HOST_GOALS AS OPPONENT_GOALS
    FROM
        MATCHES
)
SELECT
    T.TEAM_ID,
    T.TEAM_NAME,
    SUM(
        CASE
            WHEN M.GOALS > M.OPPONENT_GOALS THEN 3
            WHEN M.GOALS = M.OPPONENT_GOALS THEN 1
            ELSE 0
        END
    ) AS NUM_POINTS
FROM
    TEAMS AS T
LEFT JOIN
    TWOWAYMATCHES AS M ON T.TEAM_ID = M.TEAM_ID
GROUP BY
    T.TEAM_ID,
    T.TEAM_NAME
ORDER BY
    NUM_POINTS DESC,
    T.TEAM_ID;
```
---
### 1264. Page Recommendations
```sql
WITH
  USERTOFRIENDS AS (
    SELECT USER1_ID AS USER_ID, USER2_ID AS FRIEND_ID FROM FRIENDSHIP
    UNION ALL
    SELECT USER2_ID AS USER_ID, USER1_ID AS FRIEND_ID FROM FRIENDSHIP
  )
SELECT FRIENDLIKES.PAGE_ID AS RECOMMENDED_PAGE
FROM USERTOFRIENDS
LEFT JOIN LIKES AS FRIENDLIKES
  ON (USERTOFRIENDS.FRIEND_ID = FRIENDLIKES.USER_ID)
LEFT JOIN LIKES AS USERLIKES
  ON (
    USERTOFRIENDS.USER_ID = USERLIKES.USER_ID
    AND FRIENDLIKES.PAGE_ID = USERLIKES.PAGE_ID)
WHERE
  USERTOFRIENDS.USER_ID = 1
  AND USERLIKES.PAGE_ID IS NULL
  AND FRIENDLIKES.PAGE_ID IS NOT NULL
GROUP BY 1;
```
---
### 1270. All People Report to the Given Manager
```sql
SELECT
    EMPLOYEE.EMPLOYEE_ID
FROM
    EMPLOYEES AS EMPLOYEE
INNER JOIN
    EMPLOYEES AS DIRECTMANAGER ON (EMPLOYEE.MANAGER_ID = DIRECTMANAGER.EMPLOYEE_ID)
INNER JOIN
    EMPLOYEES AS SKIPMANAGER ON (DIRECTMANAGER.MANAGER_ID = SKIPMANAGER.EMPLOYEE_ID)
WHERE
    SKIPMANAGER.MANAGER_ID = 1 AND EMPLOYEE.EMPLOYEE_ID != 1;
```
---
### 1285. Find the Start and End Number of Continuous Ranges
```sql
WITH LOGTOROWNUMBER AS (
    SELECT
        LOG_ID,
        ROW_NUMBER() OVER(ORDER BY LOG_ID) AS ROW_NUMBER
    FROM LOGS
)
SELECT
    MIN(LOG_ID) AS START_ID,
    MAX(LOG_ID) AS END_ID
FROM LOGTOROWNUMBER
GROUP BY LOG_ID - ROW_NUMBER;
```
---
### 1308. Running Total for Different Genders
```sql
SELECT
    GENDER,
    DAY,
    SUM(SCORE_POINTS) OVER(
        PARTITION BY GENDER
        ORDER BY DAY
    ) AS TOTAL
FROM SCORES
ORDER BY 1, 2;
```
---
### 1321. Restaurant Growth
```sql
SELECT 
	VISITED_ON, 
    SUM(SUM(AMOUNT)) OVER(ORDER BY VISITED_ON ROWS BETWEEN 6 PRECEDING AND CURRENT ROW)   AS'AMOUNT',
    ROUND(CAST(SUM(SUM(AMOUNT)) OVER(ORDER BY VISITED_ON ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS FLOAT)/7.0 ,2) AS'AVERAGE_AMOUNT' 
FROM CUSTOMER 
GROUP BY VISITED_ON
ORDER BY VISITED_ON
OFFSET 6 ROWS  
```
---
### 1341. Movie Rating
```sql
WITH THEMOSTACTIVEUSER AS (
    SELECT TOP 1
        U.NAME
    FROM
        USERS AS U
        INNER JOIN MOVIERATING AS MR ON U.USER_ID = MR.USER_ID
    GROUP BY
        U.USER_ID,
        U.NAME
    ORDER BY
        COUNT(*) DESC,
        U.NAME
),
THEBESTMOVIEFEBRUARY AS (
    SELECT TOP 1
        M.TITLE
    FROM
        MOVIES AS M
        INNER JOIN MOVIERATING AS MR ON M.MOVIE_ID = MR.MOVIE_ID
    WHERE
        MR.CREATED_AT >= '2020-02-01' AND MR.CREATED_AT < '2020-03-01'
    GROUP BY
        M.MOVIE_ID,
        M.TITLE
    ORDER BY
        AVG(CAST(MR.RATING AS DECIMAL(10,2))) DESC,
        M.TITLE
)
SELECT NAME AS RESULTS FROM THEMOSTACTIVEUSER
UNION ALL
SELECT TITLE FROM THEBESTMOVIEFEBRUARY;
```
---
### 1355. Activity Participants
```sql
WITH
    T AS (
        SELECT ACTIVITY, COUNT(1) AS CNT
        FROM FRIENDS
        GROUP BY ACTIVITY
    )
SELECT ACTIVITY
FROM T
WHERE CNT > (SELECT MIN(CNT) FROM T) AND CNT < (SELECT MAX(CNT) FROM T);
```
---
### 1364. Number of Trusted Contacts of a Customer
```sql
SELECT
    T1.INVOICE_ID,
    T2.CUSTOMER_NAME,
    T1.PRICE,
    COUNT(DISTINCT T3.CONTACT_EMAIL) AS CONTACTS_CNT,
    COUNT(DISTINCT T4.EMAIL) AS TRUSTED_CONTACTS_CNT
FROM
    INVOICES AS T1
    LEFT JOIN CUSTOMERS AS T2 ON T1.USER_ID = T2.CUSTOMER_ID
    LEFT JOIN CONTACTS AS T3 ON T1.USER_ID = T3.USER_ID
    LEFT JOIN CUSTOMERS AS T4 ON T3.CONTACT_EMAIL = T4.EMAIL
GROUP BY
    T1.INVOICE_ID,
    T2.CUSTOMER_NAME,
    T1.PRICE
ORDER BY
    T1.INVOICE_ID;
```
---
### 1393. Capital Gain/Loss
```sql
SELECT STOCK_NAME, SUM(
    CASE
        WHEN OPERATION = 'buy' THEN -PRICE
        ELSE PRICE
    END
) AS CAPITAL_GAIN_LOSS
FROM STOCKS
GROUP BY STOCK_NAME
```
---
### 1398. Customers Who Bought Products A and B but Not C
```sql
SELECT
    C.CUSTOMER_ID,
    C.CUSTOMER_NAME
FROM
    CUSTOMERS AS C
    INNER JOIN ORDERS AS O ON C.CUSTOMER_ID = O.CUSTOMER_ID
GROUP BY
    C.CUSTOMER_ID,
    C.CUSTOMER_NAME
HAVING
    SUM(CASE WHEN O.PRODUCT_NAME = 'A' THEN 1 ELSE 0 END) > 0
    AND SUM(CASE WHEN O.PRODUCT_NAME = 'B' THEN 1 ELSE 0 END) > 0
    AND SUM(CASE WHEN O.PRODUCT_NAME = 'C' THEN 1 ELSE 0 END) = 0;
```
---
### 1440. Evaluate Boolean Expression
```sql
SELECT
    LEFT_OPERAND,
    OPERATOR,
    RIGHT_OPERAND,
    CASE
        WHEN (
            (OPERATOR = '=' AND V1.VALUE = V2.VALUE)
            OR (OPERATOR = '>' AND V1.VALUE > V2.VALUE)
            OR (OPERATOR = '<' AND V1.VALUE < V2.VALUE)
        ) THEN 'true'
        ELSE 'false'
    END AS VALUE
FROM
    EXPRESSIONS AS E
    JOIN VARIABLES AS V1 ON E.LEFT_OPERAND = V1.NAME
    JOIN VARIABLES AS V2 ON E.RIGHT_OPERAND = V2.NAME;
```
---
### 1445. Apples & Oranges
```sql
SELECT
    SALE_DATE,
    SUM(CASE
        WHEN FRUIT = 'apples' THEN SOLD_NUM
        ELSE -SOLD_NUM
    END) AS DIFF
FROM SALES
GROUP BY SALE_DATE
ORDER BY SALE_DATE;
```
---
### 1454. Active Users
```sql
WITH RANKCTE AS (
    SELECT
    ID, LOGIN_DATE,
    RANK() OVER (PARTITION BY ID ORDER BY LOGIN_DATE) AS RK
    FROM (SELECT DISTINCT ID, CONVERT(DATE, LOGIN_DATE) AS LOGIN_DATE FROM LOGINS) L
),
GROUPINGCTE AS (
    SELECT *,
    DATEADD(DAY, -RK, LOGIN_DATE) AS GRP_DATE
    FROM RANKCTE
),
FINALIDS AS (
    SELECT ID 
    FROM GROUPINGCTE
    GROUP BY ID, GRP_DATE
    HAVING COUNT(*)>=5
)
SELECT F.ID, A.NAME
FROM FINALIDS F
JOIN ACCOUNTS A 
ON F.ID = A.ID
ORDER BY F.ID;
```
---
### 1459. Rectangles Area
```sql
SELECT
    P1.ID AS P1,
    P2.ID AS P2,
    ABS(P1.X_VALUE - P2.X_VALUE) * ABS(P1.Y_VALUE - P2.Y_VALUE) AS AREA
FROM
    POINTS AS P1
    JOIN POINTS AS P2 ON P1.ID < P2.ID
WHERE P1.X_VALUE != P2.X_VALUE AND P1.Y_VALUE != P2.Y_VALUE
ORDER BY AREA DESC, P1, P2;
```
---
### 1468. Calculate Salaries
```sql
SELECT
    S.COMPANY_ID,
    EMPLOYEE_ID,
    EMPLOYEE_NAME,
    ROUND(
        CASE
            WHEN TOP < 1000 THEN SALARY
            WHEN TOP >= 1000
            AND TOP <= 10000 THEN SALARY * 0.76
            ELSE SALARY * 0.51
        END
    ) AS SALARY
FROM
    SALARIES AS S
    JOIN (
        SELECT COMPANY_ID, MAX(SALARY) AS TOP
        FROM SALARIES
        GROUP BY COMPANY_ID
    ) AS T
        ON S.COMPANY_ID = T.COMPANY_ID;
```
---
### 1501. Countries You Can Safely Invest In
```sql
SELECT
    COUNTRY.NAME AS COUNTRY
FROM
    PERSON
    INNER JOIN COUNTRY ON (SUBSTRING(PERSON.PHONE_NUMBER, 1, 3) = COUNTRY.COUNTRY_CODE)
    INNER JOIN CALLS ON (PERSON.ID IN (CALLS.CALLER_ID, CALLS.CALLEE_ID))
GROUP BY
    COUNTRY.NAME
HAVING
    AVG(CALLS.DURATION) > (
        SELECT
            AVG(DURATION)
        FROM
            CALLS
    );
```
---
### 1532. The Most Recent Three Orders
```sql
    SELECT
      ORDER_ID,
      ORDER_DATE,
      CUSTOMER_ID,
      ROW_NUMBER() OVER(
        PARTITION BY CUSTOMER_ID
        ORDER BY ORDER_DATE DESC
      ) AS ROW_NUMBER
    FROM ORDERS
  )
SELECT
  CUSTOMERS.NAME AS CUSTOMER_NAME,
  CUSTOMERS.CUSTOMER_ID,
  ORDERSWITHROWNUMBER.ORDER_ID,
  ORDERSWITHROWNUMBER.ORDER_DATE
FROM ORDERSWITHROWNUMBER
INNER JOIN CUSTOMERS
  ON ORDERSWITHROWNUMBER.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID
WHERE ORDERSWITHROWNUMBER.ROW_NUMBER <= 3
ORDER BY CUSTOMER_NAME, CUSTOMER_ID, ORDER_DATE DESC;
```
---
### 1549. The Most Recent Orders for Each Product
```sql
WITH RANKEDPRODUCTS AS (
    SELECT
      PRODUCTS.PRODUCT_NAME,
      PRODUCTS.PRODUCT_ID,
      ORDERS.ORDER_ID,
      ORDERS.ORDER_DATE,
      RANK() OVER(
        PARTITION BY PRODUCTS.PRODUCT_NAME
        ORDER BY ORDERS.ORDER_DATE DESC
      ) AS RNK
    FROM PRODUCTS
    INNER JOIN ORDERS
      ON PRODUCTS.PRODUCT_ID = ORDERS.PRODUCT_ID
)
SELECT
  RANKEDPRODUCTS.PRODUCT_NAME,
  RANKEDPRODUCTS.PRODUCT_ID,
  RANKEDPRODUCTS.ORDER_ID,
  RANKEDPRODUCTS.ORDER_DATE
FROM RANKEDPRODUCTS
WHERE RANKEDPRODUCTS.RNK = 1;
```
---
### 1555. Bank Account Summary
```sql
WITH UPDATEDUSERS AS (
    SELECT
      USERS.USER_ID,
      USERS.USER_NAME,
      USERS.CREDIT + ISNULL(SUM(
        CASE
          WHEN USERS.USER_ID = TRANSACTIONS.PAID_BY THEN -TRANSACTIONS.AMOUNT
          WHEN USERS.USER_ID = TRANSACTIONS.PAID_TO THEN TRANSACTIONS.AMOUNT
          ELSE 0
        END
      ), 0) AS CREDIT
    FROM USERS
    LEFT JOIN TRANSACTIONS
      ON (USERS.USER_ID IN (TRANSACTIONS.PAID_BY, TRANSACTIONS.PAID_TO))
    GROUP BY
      USERS.USER_ID,
      USERS.USER_NAME,
      USERS.CREDIT
)
SELECT
  *,
  CASE
    WHEN CREDIT < 0 THEN 'yes'
    ELSE 'no'
  END AS CREDIT_LIMIT_BREACHED
FROM UPDATEDUSERS;
```
---
### 1596. The Most Frequently Ordered Products for Each Customer
```sql
WITH TMP AS (
    SELECT
        A.CUSTOMER_ID,
        B.PRODUCT_ID,
        C.PRODUCT_NAME,
        COUNT(B.ORDER_ID) OVER(PARTITION BY A.CUSTOMER_ID, B.PRODUCT_ID) AS FREQ
    FROM CUSTOMERS AS A
    JOIN ORDERS AS B
        ON A.CUSTOMER_ID = B.CUSTOMER_ID
    JOIN PRODUCTS AS C
        ON B.PRODUCT_ID = C.PRODUCT_ID
),
TMP1 AS (
    SELECT
        CUSTOMER_ID,
        PRODUCT_ID,
        PRODUCT_NAME,
        FREQ,
        DENSE_RANK() OVER(PARTITION BY CUSTOMER_ID ORDER BY FREQ DESC) AS RNK
    FROM TMP
)
SELECT DISTINCT
    CUSTOMER_ID,
    PRODUCT_ID,
    PRODUCT_NAME
FROM TMP1
WHERE
    RNK = 1;
```
---
### 1613. Find the Missing IDs
```sql
WITH CTE AS (
    -- ANCHOR MEMBER
    SELECT 1 AS ID, MAX(C.CUSTOMER_ID) AS MAX_ID
    FROM CUSTOMERS AS C

    UNION ALL

    -- RECURSIVE MEMBER
    SELECT ID + 1, MAX_ID
    FROM CTE
    WHERE ID < MAX_ID
)
SELECT ID AS IDS
FROM CTE AS C
WHERE C.ID NOT IN (
    SELECT CUSTOMER_ID
    FROM CUSTOMERS
)
ORDER BY 1 ASC;
```
---
### 1699. Number of Calls Between Two Persons
```sql
SELECT
  LEAST(FROM_ID, TO_ID) AS PERSON1,
  GREATEST(FROM_ID, TO_ID) AS PERSON2,
  COUNT(*) AS CALL_COUNT,
  SUM(DURATION) AS TOTAL_DURATION
FROM CALLS
GROUP BY 1, 2;
```
---
### 1709. Biggest Window Between Visits
```sql
SELECT 
  USER_ID, 
  MAX(DIFF) AS BIGGEST_WINDOW 
FROM 
  (
    SELECT 
      USER_ID, 
      DATEDIFF(
        COALESCE(
          LEAD(VISIT_DATE) OVER (
            PARTITION BY USER_ID 
            ORDER BY 
              VISIT_DATE
          ), 
          '2021-01-01'
        ), 
        VISIT_DATE
      ) AS DIFF 
    FROM 
      USERVISITS
  ) A 
GROUP BY 
  USER_ID 
ORDER BY 
  USER_ID;
```
---
### 1715. Count Apples and Oranges
```sql
SELECT SUM(ISNULL(BOX.APPLE_COUNT, 0) + ISNULL(CHEST.APPLE_COUNT, 0)) AS APPLE_COUNT,
       SUM(ISNULL(BOX.ORANGE_COUNT, 0) + ISNULL(CHEST.ORANGE_COUNT, 0)) AS ORANGE_COUNT
FROM BOXES AS BOX
LEFT JOIN CHESTS AS CHEST ON BOX.CHEST_ID = CHEST.CHEST_ID;
```
---
### 1747. Leetflex Banned Accounts
```sql
SELECT DISTINCT L1.ACCOUNT_ID
FROM LOGINFO AS L1
INNER JOIN LOGINFO AS L2
  ON L1.ACCOUNT_ID = L2.ACCOUNT_ID
  AND L1.IP_ADDRESS <> L2.IP_ADDRESS
  AND (L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT OR L1.LOGOUT BETWEEN L2.LOGIN AND L2.LOGOUT);
```
---
### 176. Second Highest Salary
```sql
WITH
  RANKEDEMPLOYEES AS (
    SELECT *, DENSE_RANK() OVER(ORDER BY SALARY DESC) AS RNK
    FROM EMPLOYEE
  )
SELECT MAX(SALARY) AS SECONDHIGHESTSALARY
FROM RANKEDEMPLOYEES
WHERE RNK = 2;
```
---
### 177. Nth Highest Salary
```sql
CREATE FUNCTION getNthHighestSalary(@N INT) RETURNS INT AS BEGIN RETURN (
  SELECT 
    MAX(SALARY) AS SALARY 
  FROM 
    (
      SELECT 
        *, 
        DENSE_RANK() OVER(
          ORDER BY 
            SALARY DESC
        ) AS RNK 
      FROM 
        EMPLOYEE
    ) A 
  WHERE 
    RNK = @N
);
END
```
---
### 178. Rank Scores
```sql
SELECT
  SCORE,
  DENSE_RANK() OVER(ORDER BY SCORE DESC) AS RANK
FROM SCORES
```
---
### 1783. Grand Slam Titles
```sql
SELECT 
    T.PLAYER_ID, 
    PLAYERS.PLAYER_NAME, 
    COUNT(1) AS GRAND_SLAMS_COUNT
FROM 
(
    SELECT YEAR, 'Wimbledon' AS TOURNAMENT, WIMBLEDON AS PLAYER_ID FROM CHAMPIONSHIPS
    UNION ALL
    SELECT YEAR, 'Fr_open' AS TOURNAMENT, FR_OPEN AS PLAYER_ID FROM CHAMPIONSHIPS
    UNION ALL
    SELECT YEAR, 'US_open' AS TOURNAMENT, US_OPEN AS PLAYER_ID FROM CHAMPIONSHIPS
    UNION ALL
    SELECT YEAR, 'Au_open' AS TOURNAMENT, AU_OPEN AS PLAYER_ID FROM CHAMPIONSHIPS
) T
INNER JOIN PLAYERS ON T.PLAYER_ID = PLAYERS.PLAYER_ID
GROUP BY T.PLAYER_ID, PLAYERS.PLAYER_NAME
ORDER BY GRAND_SLAMS_COUNT DESC;
-----------------------------
SELECT 
    P.PLAYER_ID, 
    P.PLAYER_NAME,
    SUM(CASE WHEN C.WIMBLEDON = P.PLAYER_ID THEN 1 ELSE 0 END) +
    SUM(CASE WHEN C.FR_OPEN = P.PLAYER_ID THEN 1 ELSE 0 END) +
    SUM(CASE WHEN C.US_OPEN = P.PLAYER_ID THEN 1 ELSE 0 END) +
    SUM(CASE WHEN C.AU_OPEN = P.PLAYER_ID THEN 1 ELSE 0 END) AS GRAND_SLAMS_COUNT
FROM 
    PLAYERS AS P
CROSS JOIN 
    CHAMPIONSHIPS AS C
GROUP BY 
    P.PLAYER_ID, 
    P.PLAYER_NAME
HAVING 
    SUM(CASE WHEN C.WIMBLEDON = P.PLAYER_ID THEN 1 ELSE 0 END) +
    SUM(CASE WHEN C.FR_OPEN = P.PLAYER_ID THEN 1 ELSE 0 END) +
    SUM(CASE WHEN C.US_OPEN = P.PLAYER_ID THEN 1 ELSE 0 END) +
    SUM(CASE WHEN C.AU_OPEN = P.PLAYER_ID THEN 1 ELSE 0 END) > 0
ORDER BY 
    GRAND_SLAMS_COUNT DESC;
```
---
### 180. Consecutive Numbers
```sql
WITH
  LOGSNEIGHBORS AS (
    SELECT
      *,
      LAG(NUM) OVER(ORDER BY ID) AS PREV_NUM,
      LEAD(NUM) OVER(ORDER BY ID) AS NEXT_NUM
    FROM LOGS
  )
SELECT DISTINCT NUM AS CONSECUTIVENUMS
FROM LOGSNEIGHBORS
WHERE
  NUM = PREV_NUM
  AND NUM = NEXT_NUM;
```
---
### 1811. Find Interview Candidates
```sql
WITH USERTOCONTEST AS (
  SELECT GOLD_MEDAL AS USER_ID, CONTEST_ID FROM CONTESTS 
  UNION ALL 
  SELECT SILVER_MEDAL AS USER_ID, CONTEST_ID FROM CONTESTS 
  UNION ALL 
  SELECT BRONZE_MEDAL AS USER_ID, CONTEST_ID FROM CONTESTS
), 
USERTOCONTESTWITHGROUPID AS (
  SELECT 
    USER_ID, 
    CONTEST_ID - ROW_NUMBER() OVER(PARTITION BY USER_ID ORDER BY CONTEST_ID) AS GROUP_ID 
  FROM 
    USERTOCONTEST
), 
CANDIDATEUSERIDS AS (
  SELECT USER_ID FROM USERTOCONTESTWITHGROUPID 
  GROUP BY USER_ID, GROUP_ID 
  HAVING COUNT(*) >= 3 
  UNION 
  SELECT GOLD_MEDAL AS USER_ID FROM CONTESTS 
  GROUP BY GOLD_MEDAL 
  HAVING COUNT(*) >= 3
) 
SELECT 
  USERS.NAME, 
  USERS.MAIL
  FROM CANDIDATEUSERIDSINNER 
  JOIN USERS ON CANDIDATEUSERIDS.USER_ID = USERS.USER_ID;
```
---
### 1831. Maximum Transaction Each Day
```sql
SELECT 
  TRANSACTION_ID 
FROM 
  (
    SELECT 
      TRANSACTION_ID, DATE(DAY) AS DATE1, AMOUNT, RANK() OVER(PARTITION BY DATE(DAY) ORDER BY AMOUNT DESC) AS RK 
    FROM 
      TRANSACTIONS
  ) AS TEMP 
WHERE 
  RK = 1 
ORDER BY 
  TRANSACTION_ID;
```
---
### 184. Department Highest Salary
```sql
WITH
  EMPLOYEESWITHMAXSALARYINDEPARTMENT AS (
    SELECT
      DEPARTMENT.NAME AS DEPARTMENT,
      EMPLOYEE.NAME AS EMPLOYEE,
      EMPLOYEE.SALARY,
      MAX(EMPLOYEE.SALARY) OVER(PARTITION BY EMPLOYEE.DEPARTMENTID) AS MAX_SALARY
    FROM EMPLOYEE
    LEFT JOIN DEPARTMENT
      ON (EMPLOYEE.DEPARTMENTID = DEPARTMENT.ID)
  )
SELECT
  DEPARTMENT AS DEPARTMENT,
  EMPLOYEE AS EMPLOYEE,
  SALARY AS SALARY
FROM EMPLOYEESWITHMAXSALARYINDEPARTMENT
WHERE SALARY = MAX_SALARY;
```
---
### 1841. League Statistics
```sql
SELECT
  T.TEAM_NAME,
  COUNT(*) AS MATCHES_PLAYED,
  SUM(CASE WHEN COMBINED.NUM_GOALS > COMBINED.NUM_CONCEDED_GOALS THEN 3 WHEN COMBINED.NUM_GOALS = COMBINED.NUM_CONCEDED_GOALS THEN 1 ELSE 0 END) AS POINTS,
  SUM(COMBINED.NUM_GOALS) AS GOAL_FOR,
  SUM(COMBINED.NUM_CONCEDED_GOALS) AS GOAL_AGAINST,
  SUM(COMBINED.NUM_GOALS) - SUM(COMBINED.NUM_CONCEDED_GOALS) AS GOAL_DIFF
FROM (
  SELECT
    HOST_TEAM AS TEAM_ID,
    HOST_GOALS AS NUM_GOALS,
    GUEST_GOALS AS NUM_CONCEDED_GOALS
  FROM MATCHES
  UNION ALL
  SELECT
    GUEST_TEAM AS TEAM_ID,
    GUEST_GOALS AS NUM_GOALS,
    HOST_GOALS AS NUM_CONCEDED_GOALS
  FROM MATCHES
) AS COMBINED
JOIN TEAMS AS T
  ON COMBINED.TEAM_ID = T.TEAM_ID
GROUP BY
  T.TEAM_NAME
ORDER BY
  POINTS DESC,
  GOAL_DIFF DESC,
  T.TEAM_NAME ASC;
```
---
### 1843. Suspicious Bank Accounts
```sql
WITH SUSPICIOUSACCOUNTTOMONTH AS (
    -- 1. IDENTIFY MONTHS WITH SUSPICIOUS INCOME
    SELECT
        T.ACCOUNT_ID,
        FORMAT(T.DAY, 'YYYYMM') AS MONTH_STR
    FROM
        TRANSACTIONS AS T
    INNER JOIN
        ACCOUNTS AS A ON T.ACCOUNT_ID = A.ACCOUNT_ID
    WHERE
        T.TYPE = 'Creditor'
    GROUP BY
        T.ACCOUNT_ID,
        FORMAT(T.DAY, 'YYYYMM')
    HAVING
        SUM(T.AMOUNT) > A.MAX_INCOME
)
-- 2. FIND ACCOUNTS WITH CONSECUTIVE SUSPICIOUS MONTHS USING A SELF-JOIN
SELECT DISTINCT
    CURRMONTH.ACCOUNT_ID
FROM
    SUSPICIOUSACCOUNTTOMONTH AS CURRMONTH
INNER JOIN
    SUSPICIOUSACCOUNTTOMONTH AS NEXTMONTH ON CURRMONTH.ACCOUNT_ID = NEXTMONTH.ACCOUNT_ID
WHERE
    DATEDIFF(MONTH, CONVERT(DATE, CURRMONTH.MONTH_STR + '01'), CONVERT(DATE, NEXTMONTH.MONTH_STR + '01')) = 1;
```
---
### 1867. Orders With Maximum Quantity Above Average
```sql
SELECT 
  ORDER_ID 
FROM 
  ORDERSDETAILS 
GROUP BY 
  ORDER_ID 
HAVING 
  MAX(QUANTITY) > (
    SELECT 
      MAX(AVG_QUANTITY) 
    FROM 
      (
        SELECT 
          ORDER_ID, 
          SUM(QUANTITY) / COUNT(PRODUCT_ID) AS AVG_QUANTITY 
        FROM 
          ORDERSDETAILS 
        GROUP BY 
          ORDER_ID
      ) T
  );
```
---
### 1875. Group Employees of the Same Salary
```sql
WITH
  EMPLOYEESWITHCOUNTPERSALARY AS (
    SELECT
      *,
      COUNT(EMPLOYEE_ID) OVER(PARTITION BY SALARY) AS COUNT_PER_SALARY
    FROM EMPLOYEES
  )
SELECT
  EMPLOYEE_ID,
  NAME,
  SALARY,
  DENSE_RANK() OVER(ORDER BY SALARY) AS TEAM_ID
FROM EMPLOYEESWITHCOUNTPERSALARY
WHERE COUNT_PER_SALARY > 1
ORDER BY TEAM_ID, EMPLOYEE_ID;
```
---
### 1907. Count Salary Categories
```sql
SELECT
  'Low Salary' AS CATEGORY,
  SUM(CASE WHEN INCOME < 20000 THEN 1 ELSE 0 END) AS ACCOUNTS_COUNT
FROM ACCOUNTS
UNION ALL
SELECT
  'Average Salary' AS CATEGORY,
  SUM(CASE WHEN INCOME >= 20000 AND INCOME <= 50000 THEN 1 ELSE 0 END) AS ACCOUNTS_COUNT
FROM ACCOUNTS
UNION ALL
SELECT
  'High Salary' AS CATEGORY,
  SUM(CASE WHEN INCOME > 50000 THEN 1 ELSE 0 END) AS ACCOUNTS_COUNT
FROM ACCOUNTS;
```
---
### 1934. Confirmation Rate
```sql
SELECT
    S.USER_ID,
    ISNULL(CAST(AVG(CAST(CASE WHEN C.ACTION = 'confirmed' THEN 1 ELSE 0 END AS FLOAT)) AS NUMERIC(10, 2)), 0) AS CONFIRMATION_RATE
FROM
    SIGNUPS AS S
LEFT JOIN
    CONFIRMATIONS AS C ON S.USER_ID = C.USER_ID
GROUP BY
    S.USER_ID;
```
---
### 1949. Strong Friendship
```sql
WITH BIDIRECTIONALFRIENDSHIPS AS (
    -- STEP 1: CREATE A TEMPORARY TABLE OF ALL FRIENDSHIPS IN BOTH DIRECTIONS.
    SELECT USER1_ID, USER2_ID FROM FRIENDSHIP
    UNION ALL
    SELECT USER2_ID, USER1_ID FROM FRIENDSHIP
),
COMMONFRIENDS AS (
    -- STEP 2: FIND PAIRS WITH AT LEAST 3 COMMON FRIENDS.
    SELECT
        T1.USER1_ID AS USER1,
        T2.USER1_ID AS USER2,
        COUNT(T1.USER2_ID) AS COMMON_FRIEND_COUNT
    FROM BIDIRECTIONALFRIENDSHIPS AS T1
    JOIN BIDIRECTIONALFRIENDSHIPS AS T2
        -- THE JOIN CONDITION MATCHES USERS WITH A COMMON FRIEND.
        ON T1.USER2_ID = T2.USER2_ID
    -- THIS CONDITION ENSURES EACH UNIQUE PAIR IS COUNTED ONLY ONCE.
    WHERE T1.USER1_ID < T2.USER1_ID
    GROUP BY T1.USER1_ID, T2.USER1_ID
    -- THE HAVING CLAUSE FILTERS FOR AT LEAST 3 COMMON FRIENDS.
    HAVING COUNT(T1.USER2_ID) >= 3
)
-- STEP 3: SELECT ONLY THE PAIRS THAT ARE ALREADY FRIENDS.
SELECT
    CF.USER1,
    CF.USER2
FROM COMMONFRIENDS CF
JOIN FRIENDSHIP F
    -- A JOIN IS USED TO CHECK FOR EXISTING FRIENDSHIPS IN A STANDARD WAY.
    ON (CF.USER1 = F.USER1_ID AND CF.USER2 = F.USER2_ID)
    OR (CF.USER1 = F.USER2_ID AND CF.USER2 = F.USER1_ID);
```
---
### 1951. All the Pairs With the Maximum Number of Common Followers
```sql
WITH R AS (
    SELECT R1.USER_ID AS USER1_ID, R2.USER_ID AS USER2_ID, COUNT(*) AS CNT
    FROM RELATIONS R1
    JOIN RELATIONS R2 ON R1.FOLLOWER_ID = R2.FOLLOWER_ID
    WHERE R1.USER_ID < R2.USER_ID
    GROUP BY R1.USER_ID, R2.USER_ID
)
SELECT USER1_ID, USER2_ID
FROM R
WHERE CNT = (SELECT MAX(CNT) FROM R);
```
---
### 1988. Find Cutoff Score for Each School
```sql
SELECT SCHOOL_ID, IFNULL(MIN(SCORE), -1) AS SCORE
    FROM SCHOOLS LEFT JOIN EXAM
    ON CAPACITY >= STUDENT_COUNT
    GROUP BY SCHOOL_ID;
```
---
### 1990. Count the Number of Experiments
```sql
WITH P AS (
    SELECT 'Android' AS PLATFORM
    UNION
    SELECT 'IOS'
    UNION
    SELECT 'Web'
),
EXP AS (
    SELECT 'Reading' AS EXPERIMENT_NAME
    UNION
    SELECT 'Sports'
    UNION
    SELECT 'Programming'
),
T AS (
    SELECT *
    FROM
        P
        CROSS JOIN EXP
)
SELECT
    T.PLATFORM,
    T.EXPERIMENT_NAME,
    COUNT(E.EXPERIMENT_ID) AS NUM_EXPERIMENTS
FROM
    T AS T
    LEFT JOIN EXPERIMENTS AS E
        ON T.PLATFORM = E.PLATFORM
        AND T.EXPERIMENT_NAME = E.EXPERIMENT_NAME
GROUP BY
    T.PLATFORM,
    T.EXPERIMENT_NAME
ORDER BY
    T.PLATFORM, T.EXPERIMENT_NAME;
```
---
### 2020. Number of Accounts That Did Not Stream
```sql
SELECT COUNT(DISTINCT SUB.ACCOUNT_ID) AS ACCOUNTS_COUNT
FROM
    SUBSCRIPTIONS AS SUB
    LEFT JOIN STREAMS AS SS ON SUB.ACCOUNT_ID = SS.ACCOUNT_ID
WHERE
    YEAR(START_DATE) <= 2021
    AND YEAR(END_DATE) >= 2021
    AND (YEAR(STREAM_DATE) != 2021 OR STREAM_DATE > END_DATE);
```
---
### 2041. Accepted Candidates From the Interviews
```sql
SELECT
    CANDIDATES.CANDIDATE_ID
FROM
    CANDIDATES
INNER JOIN
    ROUNDS ON CANDIDATES.INTERVIEW_ID = ROUNDS.INTERVIEW_ID
WHERE
    CANDIDATES.YEARS_OF_EXP >= 2
GROUP BY
    CANDIDATES.CANDIDATE_ID
HAVING
    SUM(ROUNDS.SCORE) > 15;
```
---
### 2051. The Category of Each Member in the Store
```sql
SELECT
    M.MEMBER_ID,
    NAME,
    CASE
        WHEN COUNT(V.VISIT_ID) = 0 THEN 'BRONZE'
        WHEN 100 * COUNT(CHARGED_AMOUNT) / COUNT(
            V.VISIT_ID
        ) >= 80 THEN 'DIAMOND'
        WHEN 100 * COUNT(CHARGED_AMOUNT) / COUNT(V.VISIT_ID) >= 50 THEN 'GOLD'
        ELSE 'SILVER'
    END AS CATEGORY
FROM
    MEMBERS AS M
    LEFT JOIN VISITS AS V ON M.MEMBER_ID = V.MEMBER_ID
    LEFT JOIN PURCHASES AS P ON V.VISIT_ID = P.VISIT_ID
GROUP BY MEMBER_ID;
```
---
### 2066. Account Balance
```sql
SELECT
    ACCOUNT_ID,
    DAY,
    SUM(CASE
        WHEN TYPE = 'Deposit' THEN AMOUNT
        ELSE -AMOUNT
    END) OVER (
        PARTITION BY ACCOUNT_ID
        ORDER BY DAY
    ) AS BALANCE
FROM
    TRANSACTIONS
ORDER BY
    ACCOUNT_ID,
    DAY;
```
---
### 2084. Drop Type 1 Orders for Customers With Type 0 Orders
```sql
SELECT
    ORDER_ID,
    CUSTOMER_ID,
    ORDER_TYPE
FROM
    ORDERS
WHERE
    ORDER_TYPE = 0
    OR CUSTOMER_ID NOT IN (
        SELECT
            CUSTOMER_ID
        FROM
            ORDERS
        WHERE
            ORDER_TYPE = 0
    );
-------------
WITH
  RANKEDORDERS AS (
    SELECT
      *,
      RANK() OVER(PARTITION BY CUSTOMER_ID ORDER BY ORDER_TYPE) AS RNK
    FROM ORDERS
  )
SELECT
  ORDER_ID,
  CUSTOMER_ID,
  ORDER_TYPE
FROM RANKEDORDERS
WHERE RNK = 1
```
---
### 2112. The Airport With the Most Traffic
```sql
WITH
    AIRPORTTOCOUNT AS (
        SELECT
            DEPARTURE_AIRPORT AS AIRPORT_ID,
            FLIGHTS_COUNT
        FROM
            FLIGHTS
        UNION ALL
        SELECT
            ARRIVAL_AIRPORT AS AIRPORT_ID,
            FLIGHTS_COUNT
        FROM
            FLIGHTS
    ),
    RANKEDAIRPORTS AS (
        SELECT
            AIRPORT_ID,
            RANK() OVER (ORDER BY SUM(FLIGHTS_COUNT) DESC) AS RANK
        FROM
            AIRPORTTOCOUNT
        GROUP BY
            AIRPORT_ID
    )
SELECT
    AIRPORT_ID
FROM
    RANKEDAIRPORTS
WHERE
    RANK = 1;
```
---
### 2142. The Number of Passengers in Each Bus I
```sql
SELECT
    B.BUS_ID,
    -- CALCULATE PASSENGERS ON THE CURRENT BUS
    -- BY SUBTRACTING THE CUMULATIVE COUNT OF THE PREVIOUS BUS
    -- FROM THE CUMULATIVE COUNT OF THE CURRENT BUS.
    -- THE ISNULL HANDLES THE FIRST BUS, SETTING THE LAG RESULT TO 0.
    COUNT(P.PASSENGER_ID) - ISNULL(LAG(COUNT(P.PASSENGER_ID), 1, 0) OVER (
        ORDER BY
            B.ARRIVAL_TIME
    ), 0) AS PASSENGERS_CNT
FROM
    BUSES AS B
    -- JOIN EACH BUS WITH ALL PASSENGERS WHO HAVE ARRIVED UP TO THAT BUS'S ARRIVAL TIME.
    LEFT JOIN PASSENGERS AS P ON P.ARRIVAL_TIME <= B.ARRIVAL_TIME
GROUP BY
    B.BUS_ID,
    B.ARRIVAL_TIME
ORDER BY
    B.BUS_ID;
```
---
### 2159. Order Two Columns Independently
```sql
WITH
    S AS (
        SELECT
            FIRST_COL,
            ROW_NUMBER() OVER (ORDER BY FIRST_COL) AS RK
        FROM
            DATA
    ),
    T AS (
        SELECT
            SECOND_COL,
            ROW_NUMBER() OVER (ORDER BY SECOND_COL DESC) AS RK
        FROM
            DATA
    )
SELECT
    S.FIRST_COL,
    T.SECOND_COL
FROM
    S
JOIN
    T ON S.RK = T.RK;
```
---
### 2175. The Change in Global Rankings
```sql
SELECT
    TEAMPOINTS.TEAM_ID,
    TEAMPOINTS.NAME,
    CAST(
        RANK() OVER (
            ORDER BY TEAMPOINTS.POINTS DESC,
            TEAMPOINTS.NAME
        ) AS INT
    ) - CAST(
        RANK() OVER (
            ORDER BY TEAMPOINTS.POINTS + POINTSCHANGE.POINTS_CHANGE DESC,
            TEAMPOINTS.NAME
        ) AS INT
    ) AS RANK_DIFF
FROM
    TEAMPOINTS
INNER JOIN
    POINTSCHANGE ON TEAMPOINTS.TEAM_ID = POINTSCHANGE.TEAM_ID;
```
---
### 2228. Users With Two Purchases Within Seven Days
```sql
WITH
    T AS (
        SELECT
            USER_ID,
            DATEDIFF(
                DAY,
                LAG(PURCHASE_DATE, 1) OVER (
                    PARTITION BY USER_ID
                    ORDER BY PURCHASE_DATE
                ),
                PURCHASE_DATE
            ) AS D
        FROM
            PURCHASES
    )
SELECT DISTINCT
    USER_ID
FROM
    T
WHERE
    D <= 7
ORDER BY
    USER_ID;
```
---
### 2238. Number of Times a Driver Was a Passenger
```sql
WITH T AS (SELECT DISTINCT DRIVER_ID FROM RIDES)
SELECT T.DRIVER_ID, COUNT(PASSENGER_ID) AS CNT
FROM
    T AS T
    LEFT JOIN RIDES AS R ON T.DRIVER_ID = R.PASSENGER_ID
GROUP BY 1;
```
---
### 2292. Products With Three or More Orders in Two Consecutive Years
```sql
WITH P AS (
    SELECT 
        PRODUCT_ID, 
        YEAR(PURCHASE_DATE) AS Y, 
        CASE 
            WHEN COUNT(*) >= 3 THEN 1 
            ELSE 0 
        END AS MARK
    FROM ORDERS
    GROUP BY PRODUCT_ID, YEAR(PURCHASE_DATE)
)
SELECT DISTINCT P1.PRODUCT_ID
FROM P AS P1
JOIN P AS P2 
    ON P1.PRODUCT_ID = P2.PRODUCT_ID 
    AND P1.Y = P2.Y - 1
WHERE P1.MARK = 1 AND P2.MARK = 1
ORDER BY P1.PRODUCT_ID;
-----------------
WITH PRODUCTYEARSTATS AS (
    SELECT 
        PRODUCT_ID,
        YEAR(PURCHASE_DATE) AS Y,
        COUNT(*) AS PURCHASE_COUNT
    FROM ORDERS
    GROUP BY PRODUCT_ID, YEAR(PURCHASE_DATE)
),
WITHLAG AS (
    SELECT 
        PRODUCT_ID,
        Y,
        PURCHASE_COUNT,
        LAG(PURCHASE_COUNT) OVER (
            PARTITION BY PRODUCT_ID 
            ORDER BY Y
        ) AS PREV_YEAR_COUNT
    FROM PRODUCTYEARSTATS
)
SELECT DISTINCT PRODUCT_ID
FROM WITHLAG
WHERE PURCHASE_COUNT >= 3 AND PREV_YEAR_COUNT >= 3
ORDER BY PRODUCT_ID;
```
---
### 2298. Tasks Count in the Weekend
```sql
SELECT
    SUM(CASE WHEN DATEPART(WEEKDAY, SUBMIT_DATE) IN (1, 7) THEN 1 ELSE 0 END) AS WEEKEND_CNT,
    SUM(CASE WHEN DATEPART(WEEKDAY, SUBMIT_DATE) NOT IN (1, 7) THEN 1 ELSE 0 END) AS WORKING_CNT
FROM TASKS;
```
---
### 2308. Arrange Table by Gender
```sql
WITH T AS (
    SELECT
        *,
        RANK() OVER (
            PARTITION BY GENDER
            ORDER BY USER_ID
        ) AS RK1,
        CASE
            WHEN GENDER = 'female' THEN 0
            WHEN GENDER = 'other' THEN 1
            ELSE 2
        END AS RK2
    FROM GENDERS
)
SELECT USER_ID, GENDER
FROM T
ORDER BY RK1, RK2;
```
---
### 2314. The First Day of the Maximum Recorded Degree in Each City
```sql
WITH T AS (
    SELECT
        *,
        RANK() OVER (
            PARTITION BY CITY_ID
            ORDER BY DEGREE DESC, DAY
        ) AS RK
    FROM WEATHER
)
SELECT CITY_ID, DAY, DEGREE
FROM T
WHERE RK = 1
ORDER BY CITY_ID;
```
---
### 2324. Product Sales Analysis IV
```sql
WITH SALESTOTAL AS (
    SELECT 
        S.USER_ID,
        S.PRODUCT_ID,
        SUM(S.QUANTITY * P.PRICE) AS TOTAL_SPENT
    FROM SALES S
    JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID
    GROUP BY S.USER_ID, S.PRODUCT_ID
),
RANKED AS (
    SELECT 
        USER_ID,
        PRODUCT_ID,
        RANK() OVER (
            PARTITION BY USER_ID
            ORDER BY TOTAL_SPENT DESC
        ) AS RK
    FROM SALESTOTAL
)
SELECT USER_ID, PRODUCT_ID
FROM RANKED
WHERE RK = 1;
```
---
### 2346. Compute the Rank as a Percentage
```sql
SELECT
    STUDENT_ID,
    DEPARTMENT_ID,
    ISNULL(
        ROUND(
            CAST((RANK() OVER (
                PARTITION BY DEPARTMENT_ID
                ORDER BY MARK DESC
            ) - 1) * 100.0 / 
            NULLIF(COUNT(*) OVER (PARTITION BY DEPARTMENT_ID) - 1, 0)
            AS FLOAT),
            2
        ),
        0
    ) AS PERCENTAGE
FROM STUDENTS;
```
---
### 2372. Calculate the Influence of Each Salesperson
```sql
SELECT
    SP.SALESPERSON_ID,
    NAME,
    COALESCE(SUM(PRICE), 0) AS TOTAL
FROM
    SALESPERSON AS SP
    LEFT JOIN CUSTOMER AS C ON SP.SALESPERSON_ID = C.SALESPERSON_ID
    LEFT JOIN SALES AS S ON S.CUSTOMER_ID = C.CUSTOMER_ID
GROUP BY
    SP.SALESPERSON_ID, NAME;
```
---
### 2388. Change Null Values in a Table to the Previous Value
```sql
WITH RN_CTE AS (
    SELECT ID, DRINK, ROW_NUMBER() OVER () AS RN
    FROM COFFEESHOP
),
GROUP_CTE AS (
    SELECT ID, DRINK, RN, SUM(NOT ISNULL(DRINK)) OVER (ORDER BY RN) AS GROUP_ID
    FROM RN_CTE
)
SELECT ID, MAX(DRINK) OVER (PARTITION BY GROUP_ID) AS DRINK
FROM GROUP_CTE
ORDER BY RN;
```
---
### 2394. Employees With Deductions
```sql
WITH T AS (
    SELECT
        EMPLOYEE_ID,
        SUM(
            CEILING(
                DATEDIFF(SECOND, IN_TIME, OUT_TIME) / 60.0
            )
        ) / 60.0 AS TOT
    FROM
        LOGS
    GROUP BY
        EMPLOYEE_ID
)
SELECT
    E.EMPLOYEE_ID
FROM
    EMPLOYEES AS E
LEFT JOIN
    T ON E.EMPLOYEE_ID = T.EMPLOYEE_ID
WHERE
    ISNULL(T.TOT, 0) < E.NEEDED_HOURS;
```
---
### 2686. Immediate Food Delivery III
```sql
SELECT
    ORDER_DATE,
    ROUND(100.0 * SUM(
        CASE
            WHEN CUSTOMER_PREF_DELIVERY_DATE = ORDER_DATE THEN 1
            ELSE 0
        END
    ) / COUNT(*), 2) AS IMMEDIATE_PERCENTAGE
FROM
    DELIVERY
GROUP BY
    ORDER_DATE
ORDER BY
    ORDER_DATE;
```
---
### 2688. Find Active Users
```sql
SELECT DISTINCT USER_ID
FROM USERS
WHERE USER_ID IN (
    SELECT USER_ID
    FROM (
        SELECT
            USER_ID,
            CREATED_AT,
            LAG(CREATED_AT, 1) OVER (
                PARTITION BY USER_ID
                ORDER BY CREATED_AT
            ) AS PREV_CREATED_AT
        FROM USERS
    ) AS T
    WHERE DATEDIFF(DAY, PREV_CREATED_AT, CREATED_AT) <= 7
);
```
---
### 2738. Count Occurrences in Text
```sql
SELECT 'bull' AS WORD, COUNT(*) AS COUNT
FROM FILES
WHERE CONTENT LIKE '% bull %'
UNION
SELECT 'bear' AS WORD, COUNT(*) AS COUNT
FROM FILES
WHERE CONTENT LIKE '% bear %';
```
---
### 2783. Flight Occupancy and Waitlist Analysis
```sql
SELECT
    F.FLIGHT_ID,
    CASE 
        WHEN COUNT(P.PASSENGER_ID) < F.CAPACITY THEN COUNT(P.PASSENGER_ID)
        ELSE F.CAPACITY
    END AS BOOKED_CNT,
    CASE 
        WHEN COUNT(P.PASSENGER_ID) > F.CAPACITY THEN COUNT(P.PASSENGER_ID) - F.CAPACITY
        ELSE 0
    END AS WAITLIST_CNT
FROM FLIGHTS F
LEFT JOIN PASSENGERS P ON F.FLIGHT_ID = P.FLIGHT_ID
GROUP BY F.FLIGHT_ID, F.CAPACITY
ORDER BY F.FLIGHT_ID;
```
---
### 2820. Election Results
```sql
WITH T AS (
    SELECT 
        CANDIDATE, 
        SUM(VOTE) AS TOT
    FROM (
        SELECT 
            CANDIDATE,
            1.0 / COUNT(*) OVER (PARTITION BY VOTER) AS VOTE
        FROM VOTES
        WHERE CANDIDATE IS NOT NULL
    ) AS Sub
    GROUP BY CANDIDATE
),
P AS (
    SELECT 
        CANDIDATE,
        RANK() OVER (ORDER BY TOT DESC) AS RK
    FROM T
)
SELECT CANDIDATE
FROM P
WHERE RK = 1
ORDER BY CANDIDATE;
```
---
### 2854. Rolling Average Steps
```sql
WITH T AS (
    SELECT
        USER_ID,
        STEPS_DATE,
        ROUND(
            AVG(STEPS_COUNT) OVER (
                PARTITION BY USER_ID
                ORDER BY STEPS_DATE
                ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
            ),
            2
        ) AS ROLLING_AVERAGE,
        DATEDIFF(
            DAY,
            LAG(STEPS_DATE, 2) OVER (
                PARTITION BY USER_ID
                ORDER BY STEPS_DATE
            ),
            STEPS_DATE
        ) AS DATE_DIFF
    FROM STEPS
)
SELECT
    USER_ID,
    STEPS_DATE,
    ROLLING_AVERAGE
FROM T
WHERE DATE_DIFF = 2
ORDER BY USER_ID, STEPS_DATE;
```
---
### 2893. Calculate Orders Within Each Interval
```sql
SELECT
    CEILING(CAST([MINUTE] AS FLOAT) / 6) AS INTERVAL_NO,
    SUM(ORDER_COUNT) AS TOTAL_ORDERS
FROM
    ORDERS
GROUP BY
    CEILING(CAST([MINUTE] AS FLOAT) / 6)
ORDER BY
    INTERVAL_NO;
```
---
### 2922. Market Analysis III
```sql
WITH T AS (
    SELECT
        U.SELLER_ID,
        COUNT(DISTINCT O.ITEM_ID) AS NUM_ITEMS
    FROM ORDERS AS O
    JOIN USERS AS U
        ON O.SELLER_ID = U.SELLER_ID
    JOIN ITEMS AS I
        ON O.ITEM_ID = I.ITEM_ID
    WHERE
        I.ITEM_BRAND <> U.FAVORITE_BRAND
    GROUP BY
        U.SELLER_ID
)
SELECT
    SELLER_ID,
    NUM_ITEMS
FROM T
WHERE
    NUM_ITEMS = (SELECT MAX(NUM_ITEMS) FROM T)
ORDER BY
    SELLER_ID;
```
---
### 2978. Symmetric Coordinates
```sql
WITH SYMMETRICCOORDINATES AS (
    SELECT DISTINCT C1.X, C1.Y
    FROM COORDINATES AS C1
    INNER JOIN COORDINATES AS C2
        ON C1.X = C2.Y AND C1.Y = C2.X
    WHERE C1.X < C1.Y
    UNION ALL
    SELECT X, Y
    FROM COORDINATES
    WHERE X = Y
    GROUP BY X, Y
    HAVING COUNT(*) > 1
)
SELECT X, Y
FROM SYMMETRICCOORDINATES
ORDER BY 1, 2;
```
---
### 2984. Find Peak Calling Hours for Each City
```sql
WITH T AS (
    SELECT
        *,
        RANK() OVER (PARTITION BY CITYORDER BY CNT DESC) AS RK
    FROM
        (
         SELECT
			CITY,
            DATEPART(HOUR, CALL_TIME) AS H,
            COUNT(1) AS CNT
            FROM CALLS
            GROUP BY CITY, DATEPART(HOUR, CALL_TIME)
        ) AS T
)
SELECT
    CITY,
    H AS PEAK_CALLING_HOUR,
    CNT AS NUMBER_OF_CALLS
FROM T
WHERE RK = 1
ORDER BY PEAK_CALLING_HOUR DESC, CITY DESC;
```
---
### 2986. Find Third Transaction
```sql
WITH TRANSACTIONNEIGHBORS AS (
  SELECT
    USER_ID,
    SPEND,
    TRANSACTION_DATE,
    RANK() OVER( PARTITION BY USER_IDORDER BYTRANSACTION_DATE ) AS DATE_RANK,
    FIRST_VALUE(SPEND) OVER( PARTITION BY USER_ID ORDER BY TRANSACTION_DATE ) AS FIRST_SPEND,
    LAG(SPEND) OVER( PARTITION BY USER_ID ORDER BY TRANSACTION_DATE ) AS SECOND_SPEND
  FROM
    TRANSACTIONS
)
SELECT
  USER_ID,
  SPEND AS THIRD_TRANSACTION_SPEND,
  TRANSACTION_DATE AS THIRD_TRANSACTION_DATE
FROM
  TRANSACTIONNEIGHBORS
WHERE
  DATE_RANK = 3 AND SPEND > FIRST_SPEND AND SPEND > SECOND_SPEND
ORDER BY 1;
```
---
### 2988. Manager of the Largest Department
```sql
WITH RANKEDDEPARTMENTS AS (
    -- THIS CTE RANKS DEPARTMENTS BASED ON THE NUMBER OF EMPLOYEES THEY HAVE.
    SELECT
        DEP_ID,
        DENSE_RANK() OVER (ORDER BY COUNT(*) DESC) AS RNK
    FROM
        EMPLOYEES
    GROUP BY
        DEP_ID
)
SELECT
    -- SELECTS THE EMPLOYEE'S NAME (ALIASED AS MANAGER_NAME) AND THEIR DEPARTMENT ID.
    E.EMP_NAME AS MANAGER_NAME,
    E.DEP_ID
FROM
    EMPLOYEES AS E
-- JOINS THE EMPLOYEES TABLE WITH THE RANKEDDEPARTMENTS CTE ON THE DEPARTMENT ID.
INNER JOIN
    RANKEDDEPARTMENTS AS RD
    ON E.DEP_ID = RD.DEP_ID
WHERE
    -- FILTERS FOR EMPLOYEES WHO ARE MANAGERS AND BELONG TO A DEPARTMENT WITH A RANK OF 1 (THE LARGEST DEPARTMENT).
    E.POSITION = 'Manager'
    AND RD.RNK = 1
-- ORDERS THE RESULTS BY DEPARTMENT ID.
ORDER BY
    E.DEP_ID;
```
---
### 2989. Class Performance
```sql
SELECT 
  MAX(
    ASSIGNMENT1 + ASSIGNMENT2 + ASSIGNMENT3
  ) - MIN(
    ASSIGNMENT1 + ASSIGNMENT2 + ASSIGNMENT3
  ) AS DIFFERENCE_IN_SCORE 
FROM 
  SCORES;
```
---
### 2993. Friday Purchases I
```sql
SELECT
  -- CALCULATES THE WEEK NUMBER FOR THE PURCHASE DATE RELATIVE TO NOVEMBER 1, 2023.
  DATEDIFF(WEEK, '2023-11-01', PURCHASE_DATE) + 1 AS WEEK_OF_MONTH,
  PURCHASE_DATE,
  -- SUMS THE TOTAL SPENDING FOR EACH SPECIFIC PURCHASE DATE.
  SUM(AMOUNT_SPEND) AS TOTAL_AMOUNT
FROM
  PURCHASES
WHERE
  -- FILTERS FOR RECORDS IN NOVEMBER 2023.
  MONTH(PURCHASE_DATE) = 11
  AND YEAR(PURCHASE_DATE) = 2023
  -- FILTERS FOR FRIDAYS.
  AND DATENAME(WEEKDAY, PURCHASE_DATE) = 'Friday'
GROUP BY
  -- GROUPS BY DATE TO AGGREGATE SPENDING FOR EACH FRIDAY.
  PURCHASE_DATE
ORDER BY
  -- ORDERS THE RESULTS CHRONOLOGICALLY BY THE CALCULATED WEEK NUMBER.
  WEEK_OF_MONTH;
```
---
### 3050. Pizza Toppings Cost Analysis
```sql
WITH T AS (
    -- Ranks each topping alphabetically. The rank is used to ensure unique combinations.
    SELECT
        *,
        RANK() OVER (ORDER BY TOPPING_NAME) AS RK
    FROM
        TOPPINGS
)
SELECT
    -- Concatenates the names of the three toppings to form a pizza name.
    CONCAT(T1.TOPPING_NAME, ',', T2.TOPPING_NAME, ',', T3.TOPPING_NAME) AS PIZZA,
    -- Sums the costs of the three toppings.
    T1.COST + T2.COST + T3.COST AS TOTAL_COST
FROM
    T AS T1
    JOIN T AS T2
        ON T1.RK < T2.RK -- Ensures T2's topping comes after T1's to avoid duplicates
    JOIN T AS T3
        ON T2.RK < T3.RK -- Ensures T3's topping comes after T2's
ORDER BY
    -- Orders by total cost descending (most expensive first) and then by pizza name ascending for ties.
    TOTAL_COST DESC,
    PIZZA ASC;
```
---
### 3054. Binary Tree Nodes
```sql
SELECT DISTINCT
    T1.N AS N,
    CASE
        -- A node is a 'ROOT' if it has no parent (its parent column 'P' is NULL).
        WHEN T1.P IS NULL THEN 'Root'
        -- A node is a 'LEAF' if it has a parent but no children (no matching 'N' in the T2 parent column).
        WHEN T2.P IS NULL THEN 'Leaf'
        -- A node is an 'INNER' node if it has both a parent and at least one child.
        ELSE 'Inner'
    END AS TYPE
FROM
    TREE AS T1
    -- Performs a LEFT JOIN to check if each node (T1.N) exists as a parent (T2.P) to another node.
    -- This allows us to identify nodes that have children.
    LEFT JOIN TREE AS T2 ON T1.N = T2.P
ORDER BY
    N;
```
---
### 3055. Top Percentile Fraud
```sql
WITH
  FRAUDPERCENTILE AS (
    SELECT
      POLICY_ID,
      STATE,
      FRAUD_SCORE,
      PERCENT_RANK() OVER(
        PARTITION BY STATE
        ORDER BY FRAUD_SCORE DESC
      ) AS PCT_RNK
    FROM FRAUD
  )
SELECT POLICY_ID, STATE, FRAUD_SCORE
FROM FRAUDPERCENTILE
WHERE PCT_RNK < 0.05
ORDER BY STATE, FRAUD_SCORE DESC, POLICY_ID;
```
---
### 3056. Snaps Analysis
```sql
SELECT
    AGE_BUCKET,
    ROUND(100.0 * SUM(CASE WHEN ACTIVITY_TYPE = 'send' THEN TIME_SPENT ELSE 0 END) / SUM(TIME_SPENT), 2) AS SEND_PERC,
    ROUND(100.0 * SUM(CASE WHEN ACTIVITY_TYPE = 'open' THEN TIME_SPENT ELSE 0 END) / SUM(TIME_SPENT), 2) AS OPEN_PERC
FROM
    ACTIVITIES
JOIN
    AGE ON ACTIVITIES.USER_ID = AGE.USER_ID
GROUP BY
    AGE_BUCKET;
```
---
### 3058. Friends With No Mutual Friends
```sql
WITH TWOWAYFRIENDS AS (
    -- Creates a list of all friendships in both directions (e.g., A -> B and B -> A)
    SELECT
        USER_ID1 AS USER_ID,
        USER_ID2 AS FRIEND_ID
    FROM
        FRIENDS
    UNION ALL
    SELECT
        USER_ID2,
        USER_ID1
    FROM
        FRIENDS
),
USERTOMUTUALFRIEND AS (
    -- Finds all pairs of users who have at least one mutual friend by self-joining the TWOWAYFRIENDS CTE
    SELECT
        USER1.USER_ID,
        USER2.USER_ID AS FRIEND_ID
    FROM
        TWOWAYFRIENDS AS USER1
    JOIN
        TWOWAYFRIENDS AS USER2
        ON USER1.FRIEND_ID = USER2.FRIEND_ID
    WHERE
        USER1.USER_ID != USER2.USER_ID
)
SELECT
    -- Selects the original friendship pairs
    FRIENDS.*
FROM
    FRIENDS
    -- Performs a LEFT JOIN to find friendships that do not exist in the mutual friends list
    LEFT JOIN USERTOMUTUALFRIEND
        ON (
            FRIENDS.USER_ID1 = USERTOMUTUALFRIEND.USER_ID
            AND FRIENDS.USER_ID2 = USERTOMUTUALFRIEND.FRIEND_ID
        )
-- Filters for rows where there was no match, meaning the friends have no mutual friends
WHERE
    USERTOMUTUALFRIEND.FRIEND_ID IS NULL
ORDER BY 1, 2;
```
---
### 3087. Find Trending Hashtags
```sql
SELECT 
  TOP 3 CONCAT(
    '#', 
    SUBSTRING(
      SUBSTRING(
        TWEET, 
        CHARINDEX('#', TWEET) + 1, 
        LEN(TWEET)
      ), 
      1, 
      CHARINDEX(
        ' ', 
        SUBSTRING(
          TWEET, 
          CHARINDEX('#', TWEET) + 1, 
          LEN(TWEET) + 1
        )
      ) -1
    )
  ) AS HASHTAG, 
  COUNT(*) AS HASHTAG_COUNT 
FROM 
  TWEETS 
WHERE 
  FORMAT(TWEET_DATE, 'yyyyMM') = '202402' 
GROUP BY 
  CONCAT(
    '#', 
    SUBSTRING(
      SUBSTRING(
        TWEET, 
        CHARINDEX('#', TWEET) + 1, 
        LEN(TWEET)
      ), 
      1, 
      CHARINDEX(
        ' ', 
        SUBSTRING(
          TWEET, 
          CHARINDEX('#', TWEET) + 1, 
          LEN(TWEET) + 1
        )
      ) -1
    )
  ) 
ORDER BY 
  HASHTAG_COUNT DESC, 
  HASHTAG DESC;
```
---
### 3089. Find Bursty Behavior
```sql
WITH SEVENDAYPOSTCOUNTS AS (
  SELECT 
    POST1.USER_ID, 
    COUNT(*) AS POST_COUNT 
  FROM 
    POSTS AS POST1 
    INNER JOIN POSTS AS POST2 ON POST1.USER_ID = POST2.USER_ID 
  WHERE 
    POST2.POST_DATE BETWEEN POST1.POST_DATE 
    AND DATEADD(DAY, 6, POST1.POST_DATE) 
  GROUP BY 
    POST1.USER_ID, 
    POST1.POST_ID
), 
AVERAGEWEEKLYPOSTS AS (
  SELECT 
    USER_ID, 
    COUNT(*) / 4 AS AVG_WEEKLY_POSTS 
  FROM 
    POSTS 
  WHERE 
    POST_DATE BETWEEN '2024-02-01' 
    AND '2024-02-28' 
  GROUP BY 
    USER_ID
) 
SELECT 
  SEVENDAYPOSTCOUNTS.USER_ID, 
  MAX(SEVENDAYPOSTCOUNTS.POST_COUNT) AS MAX_7DAY_POSTS, 
  AVERAGEWEEKLYPOSTS.AVG_WEEKLY_POSTS 
FROM 
  SEVENDAYPOSTCOUNTS 
  INNER JOIN AVERAGEWEEKLYPOSTS ON SEVENDAYPOSTCOUNTS.USER_ID = AVERAGEWEEKLYPOSTS.USER_ID 
GROUP BY 
  SEVENDAYPOSTCOUNTS.USER_ID, 
  AVERAGEWEEKLYPOSTS.AVG_WEEKLY_POSTS 
HAVING 
  MAX(SEVENDAYPOSTCOUNTS.POST_COUNT) >= AVERAGEWEEKLYPOSTS.AVG_WEEKLY_POSTS * 2 
ORDER BY 
  SEVENDAYPOSTCOUNTS.USER_ID;
```
---
### 3118. Friday Purchase III
```sql
WITH FRIDAYS AS (
    SELECT
        1 AS WEEK_OF_MONTH,
        CAST('2023-11-03' AS DATE) AS PURCHASE_DATE
    UNION ALL
    SELECT
        WEEK_OF_MONTH + 1,
        DATEADD(day, 7, PURCHASE_DATE)
    FROM FRIDAYS
    WHERE WEEK_OF_MONTH < 4
),
MEMBERSHIPS AS (
    SELECT 'Premium' AS MEMBERSHIP
    UNION ALL
    SELECT 'VIP'
)
SELECT
    f.WEEK_OF_MONTH,
    m.MEMBERSHIP,
    ISNULL(SUM(p.AMOUNT_SPEND), 0) AS TOTAL_AMOUNT
FROM FRIDAYS f
CROSS JOIN MEMBERSHIPS m
LEFT JOIN USERS u ON m.MEMBERSHIP = u.MEMBERSHIP
LEFT JOIN PURCHASES p ON f.PURCHASE_DATE = p.PURCHASE_DATE AND u.USER_ID = p.USER_ID
GROUP BY
    f.WEEK_OF_MONTH,
    m.MEMBERSHIP
ORDER BY
    f.WEEK_OF_MONTH,
    m.MEMBERSHIP;
```
---
### 3124. Find Longest Calls
```sql
WITH T AS (
    SELECT
        C2.FIRST_NAME,
        C1.TYPE,
        C1.DURATION,
        FORMAT(DATEADD(second, C1.DURATION, 0), 'HH:mm:ss') AS DURATION_FORMATTED,
        RANK() OVER (
            PARTITION BY C1.TYPE
            ORDER BY C1.DURATION DESC
        ) AS RK
    FROM
        CALLS AS C1
        JOIN CONTACTS AS C2 ON C1.CONTACT_ID = C2.ID
)
SELECT
    FIRST_NAME,
    TYPE,
    DURATION_FORMATTED
FROM T
WHERE RK <= 3
ORDER BY
    TYPE,
    DURATION DESC,
    FIRST_NAME DESC;
```
---
### 3126. Server Utilization Time
```sql
WITH
  SERVERNEIGHBORS AS (
    SELECT
      STATUS_TIME,
      SESSION_STATUS,
      LEAD(STATUS_TIME) OVER(
        PARTITION BY SERVER_ID
        ORDER BY STATUS_TIME
      ) AS NEXT_STATUS_TIME
    FROM SERVERS
  )
SELECT
  FLOOR(
    SUM(
      TIMESTAMPDIFF(SECOND, STATUS_TIME, NEXT_STATUS_TIME)
    ) / 86400
  ) AS TOTAL_UPTIME_DAYS
FROM SERVERNEIGHBORS
WHERE SERVERNEIGHBORS.SESSION_STATUS = 'start';
```
---
### 3140. Consecutive Available Seats II
```sql
WITH
    T AS (
        SELECT
            *,
            SEAT_ID - (RANK() OVER (ORDER BY SEAT_ID)) AS GID
        FROM CINEMA
        WHERE FREE = 1
    ),
    P AS (
        SELECT
            MIN(SEAT_ID) AS FIRST_SEAT_ID,
            MAX(SEAT_ID) AS LAST_SEAT_ID,
            COUNT(1) AS CONSECUTIVE_SEATS_LEN,
            RANK() OVER (ORDER BY COUNT(1) DESC) AS RK
        FROM T
        GROUP BY GID
    )
SELECT FIRST_SEAT_ID, LAST_SEAT_ID, CONSECUTIVE_SEATS_LEN
FROM P
WHERE RK = 1
ORDER BY 1;
```
---
### 3166. Calculate Parking Fees and Duration
```sql
WITH
    T AS (
        SELECT
            CAR_ID,
            LOT_ID,
            SUM(DATEDIFF(SECOND, ENTRY_TIME, EXIT_TIME)) AS DURATION
        FROM PARKINGTRANSACTIONS
        GROUP BY CAR_ID, LOT_ID
    ),
    P AS (
        SELECT
            *,
            RANK() OVER (
                PARTITION BY CAR_ID
                ORDER BY DURATION DESC
            ) AS RK
        FROM T
    )
SELECT
    T1.CAR_ID,
    SUM(T1.FEE_PAID) AS TOTAL_FEE_PAID,
    ROUND(
        SUM(CAST(T1.FEE_PAID AS FLOAT)) / (SUM(DATEDIFF(SECOND, T1.ENTRY_TIME, T1.EXIT_TIME)) / 3600.0),
        2
    ) AS AVG_HOURLY_FEE,
    T2.LOT_ID AS MOST_TIME_LOT
FROM
    PARKINGTRANSACTIONS AS T1
    LEFT JOIN P AS T2 ON T1.CAR_ID = T2.CAR_ID AND T2.RK = 1
GROUP BY
    T1.CAR_ID,
    T2.LOT_ID
ORDER BY T1.CAR_ID;
```
---
### 3182. Find Top Scoring Students
```sql
SELECT
    STUDENT_ID
FROM
    STUDENTS S
    JOIN COURSES C ON S.MAJOR = C.MAJOR
    LEFT JOIN ENROLLMENTS E ON S.STUDENT_ID = E.STUDENT_ID AND C.COURSE_ID = E.COURSE_ID
GROUP BY
    S.STUDENT_ID
HAVING
    SUM(CASE WHEN E.GRADE = 'A' THEN 1 ELSE 0 END) = COUNT(C.MAJOR)
ORDER BY
    S.STUDENT_ID;
```
---
### 3204. Bitwise User Permissions Analysis
```sql
-- Function directly not available in SQL Sever
SELECT
    BIT_AND(PERMISSIONS) AS COMMON_PERMS,
    BIT_OR(PERMISSIONS) AS ANY_PERMS
FROM USER_PERMISSIONS;
```
---
### 3220. Odd and Even Transactions
```sql
SELECT
    TRANSACTION_DATE,
    SUM(CASE WHEN AMOUNT % 2 = 1 THEN AMOUNT ELSE 0 END) AS ODD_SUM,
    SUM(CASE WHEN AMOUNT % 2 = 0 THEN AMOUNT ELSE 0 END) AS EVEN_SUM
FROM TRANSACTIONS
GROUP BY TRANSACTION_DATE
ORDER BY TRANSACTION_DATE;
```
---
### 3230. Customer Purchasing Behavior Analysis
```sql
WITH
    T AS (
        SELECT *
        FROM
            TRANSACTIONS
            JOIN PRODUCTS USING (PRODUCT_ID)
    ),
    P AS (
        SELECT
            CUSTOMER_ID,
            CATEGORY,
            COUNT(1) CNT,
            MAX(TRANSACTION_DATE) MAX_DATE
        FROM T
        GROUP BY 1, 2
    ),
    R AS (
        SELECT
            CUSTOMER_ID,
            CATEGORY,
            RANK() OVER (
                PARTITION BY CUSTOMER_ID
                ORDER BY CNT DESC, MAX_DATE DESC
            ) RK
        FROM P
    )
SELECT
    T.CUSTOMER_ID,
    ROUND(SUM(AMOUNT), 2) TOTAL_AMOUNT,
    COUNT(1) TRANSACTION_COUNT,
    COUNT(DISTINCT T.CATEGORY) UNIQUE_CATEGORIES,
    ROUND(AVG(AMOUNT), 2) AVG_TRANSACTION_AMOUNT,
    R.CATEGORY TOP_CATEGORY,
    ROUND(COUNT(1) * 10 + SUM(AMOUNT) / 100, 2) LOYALTY_SCORE
FROM
    T T
    JOIN R R ON T.CUSTOMER_ID = R.CUSTOMER_ID AND R.RK = 1
GROUP BY 1
ORDER BY 7 DESC, 1;
```
---
### 3252. Premier League Table Ranking II
```sql
WITH
    T AS (
        SELECT
            TEAM_NAME,
            WINS * 3 + DRAWS AS POINTS,
            RANK() OVER (ORDER BY WINS * 3 + DRAWS DESC) AS POSITION,
            COUNT(1) OVER () AS TOTAL_TEAMS
        FROM TEAMSTATS
    )
SELECT
    TEAM_NAME,
    POINTS,
    POSITION,
    CASE
        WHEN POSITION <= CEIL(TOTAL_TEAMS / 3.0) THEN 'TIER 1'
        WHEN POSITION <= CEIL(2 * TOTAL_TEAMS / 3.0) THEN 'TIER 2'
        ELSE 'TIER 3'
    END TIER
FROM T
ORDER BY 2 DESC, 1;
```
---
### 3262. Find Overlapping Shifts
```sql
SELECT
    T1.EMPLOYEE_ID,
    COUNT(*) AS OVERLAPPING_SHIFTS
FROM
    EMPLOYEESHIFTS T1
    JOIN EMPLOYEESHIFTS T2
        ON T1.EMPLOYEE_ID = T2.EMPLOYEE_ID
        AND T1.START_TIME < T2.START_TIME
        AND T1.END_TIME > T2.START_TIME
GROUP BY
    T1.EMPLOYEE_ID
HAVING
    COUNT(*) > 0
ORDER BY
    T1.EMPLOYEE_ID;
```
---
### 3278. Find Candidates for Data Scientist Position II
```sql
WITH PROJECTSKILLS AS (
    SELECT
        PROJECT_ID,
        COUNT(SKILL) AS REQUIRED_SKILLS
    FROM PROJECTS
    GROUP BY PROJECT_ID
),
CANDIDATESCORES AS (
    SELECT
        PROJECTS.PROJECT_ID,
        CANDIDATES.CANDIDATE_ID,
        100 + SUM(
            CASE
                WHEN CANDIDATES.PROFICIENCY > PROJECTS.IMPORTANCE THEN 10
                WHEN CANDIDATES.PROFICIENCY < PROJECTS.IMPORTANCE THEN -5
                ELSE 0
            END
        ) AS SCORE,
        COUNT(PROJECTS.SKILL) AS MATCHED_SKILLS
    FROM PROJECTS
    INNER JOIN CANDIDATES ON PROJECTS.SKILL = CANDIDATES.SKILL
    GROUP BY
        PROJECTS.PROJECT_ID,
        CANDIDATES.CANDIDATE_ID
),
RANKEDCANDIDATES AS (
    SELECT
        CANDIDATESCORES.PROJECT_ID,
        CANDIDATESCORES.CANDIDATE_ID,
        CANDIDATESCORES.SCORE,
        RANK() OVER (
            PARTITION BY CANDIDATESCORES.PROJECT_ID
            ORDER BY
                CANDIDATESCORES.SCORE DESC,
                CANDIDATESCORES.CANDIDATE_ID
        ) AS [RANK]
    FROM CANDIDATESCORES
    INNER JOIN PROJECTSKILLS ON CANDIDATESCORES.PROJECT_ID = PROJECTSKILLS.PROJECT_ID
    WHERE
        CANDIDATESCORES.MATCHED_SKILLS = PROJECTSKILLS.REQUIRED_SKILLS
)
SELECT
    PROJECT_ID,
    CANDIDATE_ID,
    SCORE
FROM RANKEDCANDIDATES
WHERE
    [RANK] = 1
ORDER BY
    PROJECT_ID;
```
---
### 3293. Calculate Product Final Price
```sql
SELECT
    PRODUCT_ID,
    PRICE * (100 - ISNULL(DISCOUNT, 0)) / 100 AS FINAL_PRICE,
    CATEGORY
FROM
    PRODUCTS
    LEFT JOIN DISCOUNTS ON PRODUCTS.CATEGORY = DISCOUNTS.CATEGORY
ORDER BY
    PRODUCT_ID;
```
---
### 3308. Find Top Performing Driver
```sql
WITH
    T AS (
        SELECT
            FUEL_TYPE,
            DRIVER_ID,
            ROUND(AVG(RATING), 2) AS RATING,
            SUM(DISTANCE) AS DISTANCE,
            SUM(ACCIDENTS) AS ACCIDENTS
        FROM
            DRIVERS
            JOIN VEHICLES ON DRIVERS.DRIVER_ID = VEHICLES.DRIVER_ID
            JOIN TRIPS ON VEHICLES.VEHICLE_ID = TRIPS.VEHICLE_ID
        GROUP BY
            FUEL_TYPE,
            DRIVER_ID
    ),
    P AS (
        SELECT
            *,
            RANK() OVER (
                PARTITION BY FUEL_TYPE
                ORDER BY RATING DESC, DISTANCE DESC, ACCIDENTS ASC
            ) AS [RK]
        FROM T
    )
SELECT
    FUEL_TYPE, DRIVER_ID, RATING, DISTANCE
FROM P
WHERE
    [RK] = 1
ORDER BY
    FUEL_TYPE;
```
---
### 3322. Premier League Table Ranking III
```sql
WITH TEAMSTATSCALCULATED AS (
    SELECT
        SEASON_ID,
        TEAM_ID,
        TEAM_NAME,
        WINS * 3 + DRAWS AS POINTS,
        GOALS_FOR - GOALS_AGAINST AS GOAL_DIFFERENCE
    FROM
        SEASONSTATS
)
SELECT
    SEASON_ID,
    TEAM_ID,
    TEAM_NAME,
    POINTS,
    GOAL_DIFFERENCE,
    RANK() OVER (
        PARTITION BY SEASON_ID
        ORDER BY
            POINTS DESC,
            GOAL_DIFFERENCE DESC,
            TEAM_NAME
    ) AS POSITION
FROM
    TEAMSTATSCALCULATED
ORDER BY
    SEASON_ID, POSITION, TEAM_NAME;
```
---
### 3328. Find Cities in Each State II
```sql
SELECT
    STATE,
    STRING_AGG(CITY, ', ') WITHIN GROUP (ORDER BY CITY) AS CITIES,
    COUNT(
        CASE
            WHEN LEFT(CITY, 1) = LEFT(STATE, 1) THEN 1
        END
    ) AS MATCHING_LETTER_COUNT
FROM CITIES
GROUP BY STATE
HAVING COUNT(CITY) >= 3 AND COUNT(CASE WHEN LEFT(CITY, 1) = LEFT(STATE, 1) THEN 1 END) > 0
ORDER BY MATCHING_LETTER_COUNT DESC, STATE;
```
---
### 3338. Second Highest Salary II
```sql
WITH
  RANKEDEMPLOYEES AS (
    SELECT *, DENSE_RANK() OVER(
      PARTITION BY DEPT
      ORDER BY SALARY DESC
    ) AS RNK
    FROM EMPLOYEES
  )
SELECT EMP_ID, DEPT
FROM RANKEDEMPLOYEES
WHERE RNK = 2
ORDER BY 1;
```
---
### 3421. Find Students Who Improved
```sql
WITH
  RANKEDSCORES AS (
    SELECT
      STUDENT_ID,
      SUBJECT,
      SCORE,
      EXAM_DATE,
      RANK() OVER (PARTITION BY STUDENT_ID, SUBJECT ORDER BY EXAM_DATE) AS RN_ASC,
      RANK() OVER (PARTITION BY STUDENT_ID, SUBJECT ORDER BY EXAM_DATE DESC) AS RN_DESC
    FROM SCORES
  ),
  FIRSTLASTSCORES AS (
    SELECT
      STUDENT_ID,
      SUBJECT,
      MIN(CASE WHEN RN_ASC = 1 THEN SCORE END) AS FIRST_SCORE,
      MAX(CASE WHEN RN_DESC = 1 THEN SCORE END) AS LATEST_SCORE
    FROM RANKEDSCORES GROUP BY STUDENT_ID, SUBJECT
    HAVING COUNT(*) > 1
  )
SELECT STUDENT_ID, SUBJECT, FIRST_SCORE, LATEST_SCORE
FROM FIRSTLASTSCORES
WHERE LATEST_SCORE > FIRST_SCORE
ORDER BY STUDENT_ID, SUBJECT
```
---
### 3475. DNA Pattern Recognition
```sql
SELECT
  *,
  IIF(DNA_SEQUENCE LIKE 'ATG%', 1, 0) AS HAS_START,
  IIF(DNA_SEQUENCE LIKE '%TAA' OR DNA_SEQUENCE LIKE '%TAG' OR DNA_SEQUENCE LIKE '%TGA', 1, 0) AS HAS_STOP,
  IIF(DNA_SEQUENCE LIKE '%ATAT%', 1, 0) AS HAS_ATAT,
  IIF(DNA_SEQUENCE LIKE '%GGG%', 1, 0) AS HAS_GGG
FROM SAMPLES
ORDER BY SAMPLE_ID;
```
---
### 3497. Analyze Subscription Conversion
```sql
WITH
  FREETRIAL AS (
    SELECT USER_ID, AVG(ACTIVITY_DURATION * 1.0) AS AVG_FREE_TRIAL_DURATION
    FROM USERACTIVITY
    WHERE ACTIVITY_TYPE = 'free_trial'
    GROUP BY USER_ID
  ),
  PAID AS (
    SELECT USER_ID, AVG(ACTIVITY_DURATION * 1.0) AS AVG_PAID_DURATION
    FROM USERACTIVITY
    WHERE ACTIVITY_TYPE = 'paid'
    GROUP BY USER_ID
  ),
  CONVERTEDUSERS AS (
    SELECT DISTINCT FREETRIAL.USER_ID
    FROM FREETRIAL
    INNER JOIN PAID
      ON FREETRIAL.USER_ID = PAID.USER_ID
  )
SELECT
  CONVERTEDUSERS.USER_ID,
  ROUND(FREETRIAL.AVG_FREE_TRIAL_DURATION, 2) AS TRIAL_AVG_DURATION,
  ROUND(PAID.AVG_PAID_DURATION, 2) AS PAID_AVG_DURATION
FROM CONVERTEDUSERS
INNER JOIN FREETRIAL
  ON CONVERTEDUSERS.USER_ID = FREETRIAL.USER_ID
INNER JOIN PAID
  ON CONVERTEDUSERS.USER_ID = PAID.USER_ID
ORDER BY 1;
```
---
### 3521. Find Product Recommendation Pairs
```sql
WITH PRODUCTPAIRS AS (
    SELECT
        P1.USER_ID,
        P1.PRODUCT_ID AS PRODUCT1_ID,
        P2.PRODUCT_ID AS PRODUCT2_ID
    FROM
        PRODUCTPURCHASES AS P1
    JOIN
        PRODUCTPURCHASES AS P2
        ON P1.USER_ID = P2.USER_ID
    WHERE
        P1.PRODUCT_ID < P2.PRODUCT_ID
)
SELECT
    TP.PRODUCT1_ID,
    TP.PRODUCT2_ID,
    PI1.CATEGORY AS PRODUCT1_CATEGORY,
    PI2.CATEGORY AS PRODUCT2_CATEGORY,
    COUNT(DISTINCT TP.USER_ID) AS CUSTOMER_COUNT
FROM
    PRODUCTPAIRS AS TP
JOIN
    PRODUCTINFO AS PI1
    ON TP.PRODUCT1_ID = PI1.PRODUCT_ID
JOIN
    PRODUCTINFO AS PI2
    ON TP.PRODUCT2_ID = PI2.PRODUCT_ID
GROUP BY
    TP.PRODUCT1_ID,
    TP.PRODUCT2_ID,
    PI1.CATEGORY,
    PI2.CATEGORY
HAVING
    COUNT(DISTINCT TP.USER_ID) >= 3
ORDER BY
    CUSTOMER_COUNT DESC,
    PRODUCT1_ID ASC,
    PRODUCT2_ID ASC;
```
---
### 3564. Seasonal Sales Analysis
```sql
WITH
    SEASONALSALES AS (
        SELECT
            CASE
                WHEN MONTH(S.SALE_DATE) IN (12, 1, 2) THEN 'Winter'
                WHEN MONTH(S.SALE_DATE) IN (3, 4, 5) THEN 'Spring'
                WHEN MONTH(S.SALE_DATE) IN (6, 7, 8) THEN 'Summer'
                WHEN MONTH(S.SALE_DATE) IN (9, 10, 11) THEN 'Fall'
            END AS SEASON,
            P.CATEGORY,
            SUM(S.QUANTITY) AS TOTAL_QUANTITY,
            SUM(S.QUANTITY * S.PRICE) AS TOTAL_REVENUE
        FROM
            SALES AS S
        JOIN PRODUCTS AS P
            ON S.PRODUCT_ID = P.PRODUCT_ID
        GROUP BY
            CASE
                WHEN MONTH(S.SALE_DATE) IN (12, 1, 2) THEN 'Winter'
                WHEN MONTH(S.SALE_DATE) IN (3, 4, 5) THEN 'Spring'
                WHEN MONTH(S.SALE_DATE) IN (6, 7, 8) THEN 'Summer'
                WHEN MONTH(S.SALE_DATE) IN (9, 10, 11) THEN 'Fall'
            END,
            P.CATEGORY
    ),
    TOPCATEGORYPERSEASON AS (
        SELECT
            SEASON,
            CATEGORY,
            TOTAL_QUANTITY,
            TOTAL_REVENUE,
            RANK() OVER (
                PARTITION BY SEASON
                ORDER BY TOTAL_QUANTITY DESC, TOTAL_REVENUE DESC
            ) AS RK
        FROM SEASONALSALES
    )
SELECT
    SEASON,
    CATEGORY,
    TOTAL_QUANTITY,
    TOTAL_REVENUE
FROM
    TOPCATEGORYPERSEASON
WHERE
    RK = 1
ORDER BY
    1;
```
---
### 3580. Find Consistently Improving Employees
```sql
WITH
    RECENT AS (
        SELECT
            EMPLOYEE_ID,
            REVIEW_DATE,
            RATING,
            ROW_NUMBER() OVER (
                PARTITION BY EMPLOYEE_ID
                ORDER BY REVIEW_DATE DESC
            ) AS RN,
            (
                LAG(RATING) OVER (
                    PARTITION BY EMPLOYEE_ID
                    ORDER BY REVIEW_DATE DESC
                ) - RATING
            ) AS DELTA
        FROM PERFORMANCE_REVIEWS
    )
SELECT
    R.EMPLOYEE_ID,
    E.NAME,
    SUM(R.DELTA) AS IMPROVEMENT_SCORE
FROM
    RECENT R
    JOIN EMPLOYEES E ON R.EMPLOYEE_ID = E.EMPLOYEE_ID
WHERE R.RN > 1 AND R.RN <= 3
GROUP BY R.EMPLOYEE_ID, E.NAME
HAVING COUNT(*) = 2 AND MIN(R.DELTA) > 0
ORDER BY 3 DESC, 2;
```
---
### 3586. Find COVID Recovery Patients
```sql
WITH
    FIRST_POSITIVE AS (
        SELECT
            PATIENT_ID,
            MIN(TEST_DATE) AS FIRST_POSITIVE_DATE
        FROM COVID_TESTS
        WHERE RESULT = 'Positive'
        GROUP BY PATIENT_ID
    ),
    FIRST_NEGATIVE_AFTER_POSITIVE AS (
        SELECT
            T.PATIENT_ID,
            MIN(T.TEST_DATE) AS FIRST_NEGATIVE_DATE
        FROM
            COVID_TESTS T
            JOIN FIRST_POSITIVE P
                ON T.PATIENT_ID = P.PATIENT_ID AND T.TEST_DATE > P.FIRST_POSITIVE_DATE
        WHERE T.RESULT = 'Negative'
        GROUP BY T.PATIENT_ID
    )
SELECT
    P.PATIENT_ID,
    P.PATIENT_NAME,
    P.AGE,
    DATEDIFF(day, F.FIRST_POSITIVE_DATE, N.FIRST_NEGATIVE_DATE) AS RECOVERY_TIME
FROM
    FIRST_POSITIVE F
    JOIN FIRST_NEGATIVE_AFTER_POSITIVE N ON F.PATIENT_ID = N.PATIENT_ID
    JOIN PATIENTS P ON P.PATIENT_ID = F.PATIENT_ID
ORDER BY RECOVERY_TIME ASC, PATIENT_NAME ASC;
```
---
### 3601. Find Drivers with Improved Fuel Efficiency
```sql
SELECT A.DRIVER_ID, DRIVER_NAME
    , ROUND(FIRST_HALF_AVG, 2) FIRST_HALF_AVG
    , ROUND(SECOND_HALF_AVG, 2) SECOND_HALF_AVG
    , ROUND((SECOND_HALF_AVG - FIRST_HALF_AVG), 2) AS EFFICIENCY_IMPROVEMENT 
    FROM (
    SELECT DRIVER_ID
    , AVG(CASE WHEN MONTH(TRIP_DATE) <= 6 THEN DISTANCE_KM*1.0/FUEL_CONSUMED END) AS FIRST_HALF_AVG 
    , AVG(CASE WHEN MONTH(TRIP_DATE) > 6 THEN DISTANCE_KM*1.0/FUEL_CONSUMED END) AS SECOND_HALF_AVG

    FROM TRIPS
    GROUP BY DRIVER_ID
) A 
LEFT JOIN DRIVERS D ON A.DRIVER_ID = D.DRIVER_ID
WHERE (SECOND_HALF_AVG - FIRST_HALF_AVG) > 0
```
---
### 3611. Find Overbooked Employees
```sql
SET DATEFIRST 1; -- To start the week from Monday .It can change database to database
WITH PROCESS_1 AS (
    SELECT 
        EMPLOYEE_ID,
        DATEPART(WEEK, MEETING_DATE) AS WEEK, 
        DATEPART(YEAR, MEETING_DATE) AS YR,
        SUM(DURATION_HOURS) AS DURATION_TOTAL
    FROM MEETINGS
    GROUP BY 
        EMPLOYEE_ID, 
        DATEPART(WEEK, MEETING_DATE), 
        DATEPART(YEAR, MEETING_DATE)
)
SELECT 
    P.EMPLOYEE_ID, 
    E.EMPLOYEE_NAME, 
    E.DEPARTMENT, 
    COUNT(P.EMPLOYEE_ID) AS MEETING_HEAVY_WEEKS 
FROM PROCESS_1 P
INNER JOIN EMPLOYEES E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID
WHERE DURATION_TOTAL > 20
GROUP BY 
    P.EMPLOYEE_ID, 
    E.EMPLOYEE_NAME, 
    E.DEPARTMENT
HAVING COUNT(P.EMPLOYEE_ID) > 1
ORDER BY 
    MEETING_HEAVY_WEEKS DESC, 
    EMPLOYEE_NAME;
```
---
### 3626. Find Stores with Inventory Imbalance
```sql
WITH MIN_MAX_PRODUCT AS (
  SELECT 
    STORE_ID, 
    MIN(PRICE) AS MIN_PRICE, 
    MAX(PRICE) AS MAX_PRICE 
  FROM 
    INVENTORY 
  GROUP BY 
    STORE_ID 
  HAVING 
    COUNT(DISTINCT PRODUCT_NAME) > = 3
), 
MIN_MAX_PRODUCT_QUANT AS (
  SELECT 
    INV.STORE_ID, 
    ROUND(
      MIN(
        CASE WHEN MIN_PRICE = PRICE THEN QUANTITY ELSE NULL END
      ) * 1.0 / MAX(
        CASE WHEN MAX_PRICE = PRICE THEN QUANTITY ELSE NULL END
      ), 
      2
    ) AS IMBALANCE_RATIO, 
    MIN(
      CASE WHEN MIN_PRICE = PRICE THEN PRODUCT_NAME ELSE NULL END
    ) AS CHEAPEST_PRODUCT, 
    MAX(
      CASE WHEN MAX_PRICE = PRICE THEN PRODUCT_NAME ELSE NULL END
    ) AS MOST_EXP_PRODUCT 
  FROM 
    INVENTORY INV 
    INNER JOIN MIN_MAX_PRODUCT P ON P.STORE_ID = INV.STORE_ID 
  GROUP BY 
    INV.STORE_ID
) 
SELECT 
  A.STORE_ID, 
  STORE_NAME, 
  LOCATION, 
  MOST_EXP_PRODUCT, 
  CHEAPEST_PRODUCT, 
  IMBALANCE_RATIO 
FROM 
  MIN_MAX_PRODUCT_QUANT A 
  INNER JOIN STORES S ON S.STORE_ID = A.STORE_ID 
  AND IMBALANCE_RATIO > 1
ORDER BY 
  6 DESC, 2 ASC
```
---
### 3657. Find Loyal Customers
```sql
```
---
### 534. Game Play Analysis III
```sql
SELECT  
    ACTIVITY.PLAYER_ID,  
    ACTIVITY.EVENT_DATE,  
    SUM(PREVACTIVITY.GAMES_PLAYED) AS GAMES_PLAYED_SO_FAR
FROM ACTIVITY
INNER JOIN ACTIVITY AS PREVACTIVITY  
    ON (    
        ACTIVITY.PLAYER_ID = PREVACTIVITY.PLAYER_ID    
        AND ACTIVITY.EVENT_DATE >= PREVACTIVITY.EVENT_DATE
    )
GROUP BY 
    ACTIVITY.PLAYER_ID, 
    ACTIVITY.EVENT_DATE
ORDER BY 
    ACTIVITY.PLAYER_ID, 
    ACTIVITY.EVENT_DATE;
------------------------
SELECT
    PLAYER_ID,
    EVENT_DATE,
    SUM(GAMES_PLAYED) OVER (
        PARTITION BY PLAYER_ID
        ORDER BY EVENT_DATE
    ) AS GAMES_PLAYED_SO_FAR
FROM ACTIVITY
ORDER BY
    PLAYER_ID,
    EVENT_DATE;
```
---
### 550. Game Play Analysis IV
```sql
WITH PLAYERS AS (
  SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN
  FROM ACTIVITY
  GROUP BY PLAYER_ID
)
SELECT ROUND(
    CAST(COUNT(T2.PLAYER_ID) AS DECIMAL) / COUNT(T1.PLAYER_ID),
    2
  ) AS FRACTION
FROM PLAYERS AS T1
LEFT JOIN ACTIVITY AS T2
  ON T1.PLAYER_ID = T2.PLAYER_ID
  AND DATEDIFF(DAY, T1.FIRST_LOGIN, T2.EVENT_DATE) = 1;
```
---
### 570. Managers with at Least 5 Direct Reports
```sql
SELECT E1.NAME
FROM EMPLOYEE E1
JOIN (
    SELECT MANAGERID, COUNT(*) AS DIRECTREPORTS
    FROM EMPLOYEE
    GROUP BY MANAGERID
    HAVING COUNT(*) >= 5
) E2 ON E1.ID = E2.MANAGERID;
```
---
### 574. Winning Candidate
```sql
SELECT C.NAME
FROM CANDIDATE AS C
LEFT JOIN VOTE AS V ON C.ID = V.CANDIDATEID
GROUP BY C.ID, C.NAME
ORDER BY COUNT(V.CANDIDATEID) DESC
OFFSET 0 ROWS FETCH NEXT 1 ROWS ONLY
```
---
### 578. Get Highest Answer Rate Question
```sql
WITH T AS (
    SELECT
        QUESTION_ID AS SURVEY_LOG,
        CAST(SUM(CASE WHEN ACTION = 'answer' THEN 1 ELSE 0 END) OVER (PARTITION BY QUESTION_ID) AS FLOAT) /
        NULLIF(SUM(CASE WHEN ACTION = 'show' THEN 1 ELSE 0 END) OVER (PARTITION BY QUESTION_ID), 0) AS RATIO
    FROM SURVEYLOG
)
SELECT TOP 1 SURVEY_LOG
FROM T
ORDER BY RATIO DESC, SURVEY_LOG;
```
---
### 580. Count Student Number in Departments
```sql
SELECT D.DEPT_NAME, COUNT(S.STUDENT_ID) AS STUDENT_NUMBER
FROM DEPARTMENT AS D
LEFT JOIN STUDENT AS S ON D.DEPT_ID = S.DEPT_ID
GROUP BY D.DEPT_ID, D.DEPT_NAME
ORDER BY STUDENT_NUMBER DESC, D.DEPT_NAME;
```
---
### 585. Investments in
```sql
WITH T AS (
    SELECT 
        TIV_2016,
        COUNT(*) OVER (PARTITION BY TIV_2015) AS CNT_SAME_TIV_2015,
        COUNT(*) OVER (PARTITION BY LAT, LON) AS CNT_SAME_LOCATION
    FROM INSURANCE
)
SELECT ROUND(SUM(TIV_2016), 2) AS TIV_2016
FROM T
WHERE CNT_SAME_TIV_2015 > 1 AND CNT_SAME_LOCATION = 1;
```
---
### 602. Friend Requests II: Who Has the Most Friends
```sql
WITH BASE AS (
    SELECT REQUESTER_ID AS ID FROM REQUESTACCEPTED
    UNION ALL
    SELECT ACCEPTER_ID AS ID FROM REQUESTACCEPTED
)
SELECT TOP 1 ID, COUNT(*) AS NUM
FROM BASE
GROUP BY ID
ORDER BY NUM DESC;
```
---
### 608. Tree Node
```sql
SELECT DISTINCT T1.ID, (
    CASE
    WHEN T1.P_ID IS NULL  THEN 'Root'
    WHEN T1.P_ID IS NOT NULL AND T2.ID IS NOT NULL THEN 'Inner'
    WHEN T1.P_ID IS NOT NULL AND T2.ID IS NULL THEN 'Leaf'
    END
) AS TYPE 
FROM TREE T1
LEFT JOIN TREE T2
ON T1.ID = T2.P_ID
```
---
### 612. Shortest Distance in a Plane
```sql
SELECT ROUND(SQRT(MIN(POWER(p2.x - p1.x, 2) + POWER(p2.y - p1.y, 2))), 2) AS shortest
FROM point_2d p1
JOIN point_2d p2
    ON p1.x <> p2.x OR p1.y <> p2.y;
```
---
### 614. Second Degree Follower
```sql
SELECT F1.FOLLOWER, COUNT(DISTINCT F2.FOLLOWER) AS NUM
FROM FOLLOW AS F1
JOIN FOLLOW AS F2 ON F1.FOLLOWER = F2.FOLLOWEE
GROUP BY F1.FOLLOWER
ORDER BY F1.FOLLOWER;
```
---
### 626. Exchange Seats
```sql
SELECT
    CASE
        WHEN MOD(ID, 2) <> 0 AND ID = (SELECT MAX(ID) FROM SEAT) THEN ID -- ODD ID AND IT'S THE LAST ID
        WHEN MOD(ID, 2) <> 0 THEN ID + 1 -- ODD ID, SWAP WITH THE NEXT ID
        ELSE ID - 1 -- EVEN ID, SWAP WITH THE PREVIOUS ID
    END AS ID,
    STUDENT
FROM
    SEAT
ORDER BY
    ID ASC;
---------------------------
SELECT
    ID,
    CASE
        WHEN MOD(ID, 2) = 1 AND LEAD(STUDENT, 1, STUDENT) OVER (ORDER BY ID) IS NOT NULL THEN LEAD(STUDENT, 1, STUDENT) OVER (ORDER BY ID)
        WHEN MOD(ID, 2) = 0 THEN LAG(STUDENT) OVER (ORDER BY ID)
        ELSE STUDENT -- THIS CASE IS TECHNICALLY COVERED BY LEAD'S DEFAULT OR THE FIRST WHEN, BUT GOOD FOR CLARITY.
    END AS STUDENT
FROM
    SEAT
ORDER BY
    ID ASC;
```
---
### 627. Swap Salary
```sql
UPDATE SALARY SET SEX = CASE WHEN SEX = 'm' THEN 'f' ELSE 'm' END;
```
---
# Hard
### 1097. Game Play Analysis V
```sql
WITH  PLAYERTOINSTALLDATE AS (
    SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT
    FROM ACTIVITY
    GROUP BY PLAYER_ID
)
SELECT 
    PLAYERTOINSTALLDATE.INSTALL_DT,
    COUNT(*) AS INSTALLS,
    ROUND(
        CAST(SUM(IIF(DATEDIFF(DAY, PLAYERTOINSTALLDATE.INSTALL_DT, ACTIVITY.EVENT_DATE) = 1, 1, 0)) AS FLOAT) / COUNT(*),
        2
    ) AS DAY1_RETENTION
FROM PLAYERTOINSTALLDATE
LEFT JOIN ACTIVITY
    ON PLAYERTOINSTALLDATE.PLAYER_ID = ACTIVITY.PLAYER_ID
    AND DATEDIFF(DAY, PLAYERTOINSTALLDATE.INSTALL_DT, ACTIVITY.EVENT_DATE) = 1
GROUP BY PLAYERTOINSTALLDATE.INSTALL_DT;
```
---
### 1127. User Purchase Platform
```sql
```
---
### 1159. Market Analysis II
```sql
```
---
### 1194. Tournament Winners
```sql
```
---
### 1225. Report Contiguous Dates
```sql
```
---
### 1336. Number of Transactions per Visit
```sql
```
---
### 1369. Get the Second Most Recent Activity
```sql
```
---
### 1384. Total Sales Amount by Year
```sql
```
---
### 1412. Find the Quiet Students in All Exams
```sql
```
---
### 1479. Sales by Day of the Week
```sql
```
---
### 1635. Hopper Company Queries I
```sql
```
---
### 1645. Hopper Company Queries II
```sql
```
---
### 1651. Hopper Company Queries III
```sql
```
---
### 1767. Find the Subtasks That Did Not Execute
```sql
```
---
### 185. Department Top Three Salaries
```sql
```
---
### 1892. Page Recommendations II
```sql
```
---
### 1917. Leetcodify Friends Recommendations
```sql
```
---
### 1919. Leetcodify Similar Friends
```sql
```
---
### 1972. First and Last Call On the Same Day
```sql
```
---
### 2004. The Number of Seniors and Juniors to Join the Company
```sql
```
---
### 2010. The Number of Seniors and Juniors to Join the Company II
```sql
```
---
### 2118. Build the Equation
```sql
```
---
### 2153. The Number of Passengers in Each Bus II
```sql
```
---
### 2173. Longest Winning Streak
```sql
```
---
### 2199. Finding the Topic of Each Post
```sql
```
---
### 2252. Dynamic Pivoting of a Table
```sql
```
---
### 2253. Dynamic Unpivoting of a Table
```sql
```
---
### 2362. Generate the Invoice
```sql
```
---
### 2474. Customers With Strictly Increasing Purchases
```sql
```
---
### 2494. Merge Overlapping Events in the Same Hall
```sql
```
---
### 262. Trips and Users
```sql
```
---
### 2701. Consecutive Transactions with Increasing Amounts
```sql
```
---
### 2720. Popularity Percentage
```sql
```
---
### 2752. Customers with Maximum Number of Transactions on Consecutive Days
```sql
```
---
### 2793. Status of Flight Tickets
```sql
```
---
### 2991. Top Three Wineries
```sql
```
---
### 2994. Friday Purchases II
```sql
```
---
### 2995. Viewers Turned Streamers
```sql
```
---
### 3052. Maximize Items
```sql
```
---
### 3057. Employees Project Allocation
```sql
```
---
### 3060. User Activities within Time Bounds
```sql
```
---
### 3061. Calculate Trapping Rain Water
```sql
```
---
### 3103. Find Trending Hashtags II
```sql
```
---
### 3156. Employee Task Duration and Concurrent Tasks
```sql
```
---
### 3188. Find Top Scoring Students II
```sql
```
---
### 3214. Year on Year Growth Rate
```sql
```
---
### 3236. CEO Subordinate Hierarchy
```sql
```
---
### 3268. Find Overlapping Shifts II
```sql
```
---
### 3368. First Letter Capitalization
```sql
```
---
### 3374. First Letter Capitalization II
```sql
```
---
### 3384. Team Dominance by Pass Success
```sql
```
---
### 3390. Longest Team Pass Streak
```sql
```
---
### 3401. Find Circular Gift Exchange Chains
```sql
-- BUILD GIFT CHAINS RECURSIVELY
WITH RECURSIVE CHAINS AS (
  -- BASE CASE: EACH GIVER STARTS A CHAIN
  SELECT *, GIVER_ID AS START_ID
  FROM SECRETSANTA

  UNION ALL

  -- RECURSIVE CASE: EXTEND CHAIN IF NO CYCLE
  SELECT S.*, C.START_ID
  FROM SECRETSANTA S
  JOIN CHAINS C
    ON S.GIVER_ID = C.RECEIVER_ID
   AND S.GIVER_ID != C.START_ID
),

-- SUMMARIZE EACH CHAIN BY START_ID
CHAINSUMMARY AS (
  SELECT
    START_ID,
    COUNT(*) AS CHAIN_LENGTH,
    SUM(GIFT_VALUE) AS TOTAL_GIFT_VALUE
  FROM CHAINS
  GROUP BY START_ID
),

-- GET UNIQUE CHAIN PATTERNS
UNIQUECHAINS AS (
  SELECT DISTINCT CHAIN_LENGTH, TOTAL_GIFT_VALUE
  FROM CHAINSUMMARY
)

-- RANK CHAINS BY LENGTH AND VALUE
SELECT
  RANK() OVER (
    ORDER BY CHAIN_LENGTH DESC, TOTAL_GIFT_VALUE DESC
  ) AS CHAIN_ID,
  CHAIN_LENGTH,
  TOTAL_GIFT_VALUE
FROM UNIQUECHAINS;
```
---
### 3451. Find Invalid IP Addresses
```sql
SELECT L.IP,
       COUNT(*) AS INVALID_COUNT
FROM LOGS L
WHERE (
    -- IP MUST HAVE EXACTLY 4 PARTS
    (SELECT COUNT(*) FROM STRING_SPLIT(L.IP, '.')) <> 4
    OR
    -- ANY PART > 255
    EXISTS (
        SELECT 1
        FROM STRING_SPLIT(L.IP, '.')
        WHERE TRY_CAST([VALUE] AS INT) > 255
    )
    OR
    -- ANY PART HAS LEADING ZEROS
    EXISTS (
        SELECT 1
        FROM STRING_SPLIT(L.IP, '.')
        WHERE LEN([VALUE]) > 1 AND LEFT([VALUE], 1) = '0'
    )
)
GROUP BY L.IP
ORDER BY INVALID_COUNT DESC, L.IP DESC;
```
---
### 3482. Analyze Organization Hierarchy
```sql
WITH HIERARCHY AS (
    SELECT EMPLOYEE_ID, EMPLOYEE_NAME, MANAGER_ID, SALARY, DEPARTMENT, 1 AS LEVEL
    FROM EMPLOYEES
    WHERE MANAGER_ID IS NULL

    UNION ALL

    SELECT E.EMPLOYEE_ID, E.EMPLOYEE_NAME, E.MANAGER_ID, E.SALARY, E.DEPARTMENT, H.LEVEL + 1
    FROM EMPLOYEES E
    INNER JOIN HIERARCHY H ON E.MANAGER_ID = H.EMPLOYEE_ID
),
TEAMSIZE AS (
    SELECT EMPLOYEE_ID AS MANAGER_ID, EMPLOYEE_ID AS MEMBER_ID
    FROM EMPLOYEES

    UNION ALL

    SELECT TS.MANAGER_ID, E.EMPLOYEE_ID
    FROM TEAMSIZE TS
    INNER JOIN EMPLOYEES E ON E.MANAGER_ID = TS.MEMBER_ID
),
BUDGET AS (
    SELECT TS.MANAGER_ID, COUNT(*) - 1 AS TEAM_SIZE, SUM(E.SALARY) AS BUDGET
    FROM TEAMSIZE TS
    INNER JOIN EMPLOYEES E ON TS.MEMBER_ID = E.EMPLOYEE_ID
    GROUP BY TS.MANAGER_ID
)
SELECT 
    E.EMPLOYEE_ID,
    E.EMPLOYEE_NAME,
    H.LEVEL,
    B.TEAM_SIZE,
    B.BUDGET
FROM EMPLOYEES E
INNER JOIN HIERARCHY H ON E.EMPLOYEE_ID = H.EMPLOYEE_ID
INNER JOIN BUDGET B ON E.EMPLOYEE_ID = B.MANAGER_ID
ORDER BY H.LEVEL ASC, B.BUDGET DESC, E.EMPLOYEE_NAME ASC;
```
---
### 3554. Find Category Recommendation Pairs
```sql
WITH USERCATEGORY AS (
    SELECT DISTINCT PP.USER_ID, PI.CATEGORY
    FROM PRODUCTPURCHASES PP
    JOIN PRODUCTINFO PI ON PP.PRODUCT_ID = PI.PRODUCT_ID
),
CATEGORYPAIRS AS (
    SELECT 
        UC1.USER_ID,
        UC1.CATEGORY AS CATEGORY1,
        UC2.CATEGORY AS CATEGORY2
    FROM USERCATEGORY UC1
    JOIN USERCATEGORY UC2 
        ON UC1.USER_ID = UC2.USER_ID 
        AND UC1.CATEGORY < UC2.CATEGORY
)
SELECT 
    CATEGORY1,
    CATEGORY2,
    COUNT(DISTINCT USER_ID) AS CUSTOMER_COUNT
FROM CATEGORYPAIRS
GROUP BY CATEGORY1, CATEGORY2
HAVING COUNT(DISTINCT USER_ID) >= 3
ORDER BY CUSTOMER_COUNT DESC, CATEGORY1 ASC, CATEGORY2 ASC;
```
---
### 3617. Find Students with Study Spiral Pattern
```sql
WITH STUDENT_SESSION_COUNTS AS (
    SELECT STUDENT_ID, SUBJECT, COUNT(*) AS CNT
    FROM STUDY_SESSIONS
    GROUP BY STUDENT_ID, SUBJECT
),
STUDENTS_WHO_STUDIED_ATLEAST_3_SUBJECTS_ATLEAST_2TIMES AS (
    SELECT STUDENT_ID
    FROM STUDENT_SESSION_COUNTS
    GROUP BY STUDENT_ID
    HAVING COUNT(DISTINCT SUBJECT) > 2
       AND MIN(CNT) > 1
),
IDENTIFY_THE_DAYGAPS AS (
    SELECT STUDENT_ID, SUBJECT, HOURS_STUDIED, SESSION_DATE,
           DATEDIFF(DAY, LAG(SESSION_DATE) OVER (PARTITION BY STUDENT_ID ORDER BY SESSION_DATE), SESSION_DATE) AS DAY_GAP
    FROM STUDY_SESSIONS
),
FINDING_CONSECUTIVE_GAP_MINIMUM_2DAYS_OR_LESS AS (
    SELECT STUDENT_ID
    FROM IDENTIFY_THE_DAYGAPS
    GROUP BY STUDENT_ID
    HAVING MAX(DAY_GAP) < 3
),
STUDENT_WHO_STUDYSPIRAL_PATTERN AS (
    SELECT S.STUDENT_ID, S.STUDENT_NAME, S.MAJOR,
           COUNT(DISTINCT SS.SUBJECT) AS CYCLE_LENGTH,
           SUM(SS.HOURS_STUDIED) AS TOTAL_STUDY_HOURS,
           COUNT(*) OVER () AS UNIQUE_STUDENT_ID_SHOULDATLEAST_MORETHAN_1_STUDENTS_IS_THE_KEY
    FROM STUDENTS S
    JOIN STUDY_SESSIONS SS ON S.STUDENT_ID = SS.STUDENT_ID
    JOIN STUDENTS_WHO_STUDIED_ATLEAST_3_SUBJECTS_ATLEAST_2TIMES SWS ON S.STUDENT_ID = SWS.STUDENT_ID
    JOIN FINDING_CONSECUTIVE_GAP_MINIMUM_2DAYS_OR_LESS FG ON S.STUDENT_ID = FG.STUDENT_ID
    GROUP BY S.STUDENT_ID, S.STUDENT_NAME, S.MAJOR
)
SELECT STUDENT_ID, STUDENT_NAME, MAJOR, CYCLE_LENGTH, TOTAL_STUDY_HOURS
FROM STUDENT_WHO_STUDYSPIRAL_PATTERN
WHERE UNIQUE_STUDENT_ID_SHOULDATLEAST_MORETHAN_1_STUDENTS_IS_THE_KEY > 1
ORDER BY CYCLE_LENGTH DESC, TOTAL_STUDY_HOURS DESC;
```
---
### 569. Median Employee Salary
```sql
WITH T AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY COMPANY ORDER BY SALARY ASC) AS RK,
           COUNT(ID) OVER (PARTITION BY COMPANY) AS N
    FROM EMPLOYEE
)
SELECT ID, COMPANY, SALARY
FROM T
WHERE RK >= N / 2 AND RK <= N / 2 + 1;
```
---
### 571. Find Median Given Frequency of Numbers
```sql
WITH
    T AS (
        SELECT
            *,
            SUM(FREQUENCY) OVER (ORDER BY NUM ASC) AS RK1,
            SUM(FREQUENCY) OVER (ORDER BY NUM DESC) AS RK2,
            SUM(FREQUENCY) OVER () AS S
        FROM NUMBERS
    )
SELECT
    ROUND(AVG(NUM), 1) AS MEDIAN
FROM T
WHERE RK1 >= S / 2 AND RK2 >= S / 2;
```
---
### 579. Find Cumulative Salary of an Employee
```sql
WITH T AS (
    SELECT 
        ID, 
        MONTH, 
        SUM(SALARY) OVER (
            PARTITION BY ID 
            ORDER BY MONTH 
            ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
        ) AS SALARY,
        RANK() OVER (
            PARTITION BY ID 
            ORDER BY MONTH DESC
        ) AS RK
    FROM EMPLOYEE
)
SELECT ID, MONTH, SALARY
FROM T
WHERE RK > 1
ORDER BY ID, MONTH DESC;
```
---
### 601. Human Traffic of Stadium
```sql
WITH S AS (
    SELECT *,
           ID - ROW_NUMBER() OVER (ORDER BY ID) AS RK
    FROM STADIUM
    WHERE PEOPLE >= 100
),
T AS (
    SELECT *,
           COUNT(1) OVER (PARTITION BY RK) AS CNT
    FROM S
)
SELECT ID, VISIT_DATE, PEOPLE
FROM T
WHERE CNT >= 3
```
---
### 615. Average Salary: Departments VS Company
```sql
WITH T AS (
    SELECT
        FORMAT(PAY_DATE, 'yyyy-MM') AS PAY_MONTH,
        DEPARTMENT_ID,
        AVG(AMOUNT) OVER (PARTITION BY PAY_DATE) AS COMPANY_AVG_AMOUNT,
        AVG(AMOUNT) OVER (PARTITION BY PAY_DATE, DEPARTMENT_ID) AS DEPARTMENT_AVG_AMOUNT
    FROM
        SALARY AS S
        JOIN EMPLOYEE AS E ON S.EMPLOYEE_ID = E.EMPLOYEE_ID
)
SELECT DISTINCT
    PAY_MONTH,
    DEPARTMENT_ID,
    CASE
        WHEN COMPANY_AVG_AMOUNT = DEPARTMENT_AVG_AMOUNT THEN 'same'
        WHEN COMPANY_AVG_AMOUNT < DEPARTMENT_AVG_AMOUNT THEN 'higher'
        ELSE 'lower'
    END AS COMPARISON
FROM T;
```
---
### 618. Students Report By Geography
```sql
WITH
    T AS (
        SELECT
            *,
            ROW_NUMBER() OVER (
                PARTITION BY CONTINENT
                ORDER BY NAME
            ) AS RK
        FROM STUDENT
    )
SELECT
    MAX(CASE WHEN CONTINENT = 'america' THEN NAME ELSE NULL END) AS 'AMERICA',
    MAX(CASE WHEN CONTINENT = 'asia' THEN NAME ELSE NULL END) AS 'ASIA',
    MAX(CASE WHEN CONTINENT = 'europe' THEN NAME ELSE NULL END) AS 'EUROPE'
FROM T
GROUP BY RK
ORDER BY RK;
```
---
